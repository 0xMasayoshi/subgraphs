// Code generated by sparkle. DO NOT EDIT.

package subgraph

import (
	"bytes"
	"encoding/json"
	"fmt"
	"math/big"
	"reflect"
	"time"

	eth "github.com/streamingfast/eth-go"
	"github.com/streamingfast/sparkle/entity"
	pbcodec "github.com/streamingfast/sparkle/pb/dfuse/ethereum/codec/v1"
	"github.com/streamingfast/sparkle/subgraph"
)

const (
	FactoryAddress = "0xB8ef8579EEBDCCCf69305418E49a3A545301b393"
	ZeroAddress    = "0x0000000000000000000000000000000000000000"
)

var (
	FactoryAddressBytes = eth.MustNewAddress(FactoryAddress).Bytes()
	ZeroAddressBytes    = eth.MustNewAddress(ZeroAddress).Bytes()
)

// Aliases for numerical functions
var (
	S  = entity.S
	B  = entity.B
	F  = entity.NewFloat
	FL = entity.NewFloatFromLiteral
	I  = entity.NewInt
	IL = entity.NewIntFromLiteral
	bf = func() *big.Float { return new(big.Float) }
	bi = func() *big.Int { return new(big.Int) }
)

var Definition = &subgraph.Definition{
	PackageName:         "subgraph",
	HighestParallelStep: 0,
	StartBlock:          27109220,
	IncludeFilter:       "",
	Entities: entity.NewRegistry(
		&Price{},
		&MasterDeployer{},
		&WhitelistedFactory{},
		&ConstantProductPoolFactory{},
		&ConstantProductPool{},
		&ConcentratedLiquidityPoolFactory{},
		&ConcentratedLiquidityPool{},
		&HybridPoolFactory{},
		&HybridPool{},
		&IndexPoolFactory{},
		&IndexPool{},
		&Token{},
		&Mint{},
		&Burn{},
		&Swap{},
		&Transaction{},
		&DynamicDataSourceXXX{},
	),
	DDL: ddl,
	Manifest: `specVersion: 0.0.2
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: MasterDeployer
    network: kovan
    source:
      address: '0xB8ef8579EEBDCCCf69305418E49a3A545301b393'
      startBlock: 27109220
      abi: MasterDeployer
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - MasterDeployer
        - ConstantProductPoolFactory
        - ConstantProductPool
        - ConcentratedLiquidityPoolFactory
        - ConcentratedLiquidityPool
        - HybridPoolFactory
        - HybridPool
        - IndexPoolFactory
        - IndexPool
      abis:
        - name: MasterDeployer
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/deployer/MasterDeployer.sol/MasterDeployer.json
        - name: ConstantProductPool
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/ConstantProductPool.sol/ConstantProductPool.json
        - name: ConstantProductPoolFactory
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/ConstantProductPoolFactory.sol/ConstantProductPoolFactory.json
        - name: ConcentratedLiquidityPool
          file: ../../abis/ConcentratedLiquidityPool.json
        - name: ConcentratedLiquidityPoolFactory
          file: ../../abis/ConcentratedLiquidityPoolFactory.json
        - name: HybridPool
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/HybridPool.sol/HybridPool.json
        - name: HybridPoolFactory
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/HybridPoolFactory.sol/HybridPoolFactory.json
        - name: IndexPool
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/IndexPool.sol/IndexPool.json
        - name: IndexPoolFactory
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/IndexPoolFactory.sol/IndexPoolFactory.json
        - name: ERC20
          file: ../../abis/ERC20.json
        - name: NameBytes32
          file: ../../abis/NameBytes32.json
        - name: SymbolBytes32
          file: ../../abis/SymbolBytes32.json
      eventHandlers:
        - event: DeployPool(indexed address,indexed address)
          handler: onDeployPool
        - event: TransferOwner(indexed address,indexed address)
          handler: onTransferOwner
        - event: TransferOwnerClaim(indexed address,indexed address)
          handler: onTransferOwnerClaim
        - event: AddToWhitelist(indexed address)
          handler: onAddToWhitelist
        - event: RemoveFromWhitelist(indexed address)
          handler: onRemoveFromWhitelist
        - event: BarFeeUpdated(indexed uint256)
          handler: onBarFeeUpdated
        - event: MigratorUpdated(indexed address)
          handler: onMigratorUpdated
      file: ./src/mappings/master-deployer.ts
templates:
  - kind: ethereum/contract
    name: ConstantProductPool
    network: kovan
    source:
      abi: ConstantProductPool
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/mappings/constant-product-pool.ts
      entities:
        - User
        - Mint
        - Burn
        - Swap
        - Transaction
      abis:
        - name: ConstantProductPool
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/ConstantProductPool.sol/ConstantProductPool.json
        - name: ConstantProductPoolFactory
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/ConstantProductPoolFactory.sol/ConstantProductPoolFactory.json
        - name: ERC20
          file: ../../abis/ERC20.json
        - name: NameBytes32
          file: ../../abis/NameBytes32.json
        - name: SymbolBytes32
          file: ../../abis/SymbolBytes32.json
      eventHandlers:
        - event: Mint(indexed address,uint256,uint256,indexed address)
          handler: onMint
        - event: Burn(indexed address,uint256,uint256,indexed address)
          handler: onBurn
        - event: Sync(uint256,uint256)
          handler: onSync
        - event: Swap(indexed address,indexed address,indexed address,uint256,uint256)
          handler: onSwap
        - event: Approval(indexed address,indexed address,uint256)
          handler: onApproval
        - event: Transfer(indexed address,indexed address,uint256)
          handler: onTransfer
  - kind: ethereum/contract
    name: ConcentratedLiquidityPool
    network: kovan
    source:
      abi: ConcentratedLiquidityPool
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/mappings/concentrated-liquidity-pool.ts
      entities:
        - User
      abis:
        - name: ConcentratedLiquidityPool
          file: ../../abis/ConcentratedLiquidityPool.json
        - name: ConcentratedLiquidityPoolFactory
          file: ../../abis/ConcentratedLiquidityPoolFactory.json
        - name: ERC20
          file: ../../abis/ERC20.json
        - name: NameBytes32
          file: ../../abis/NameBytes32.json
        - name: SymbolBytes32
          file: ../../abis/SymbolBytes32.json
      eventHandlers:
        - event: Mint(indexed address,uint256,uint256,indexed address)
          handler: onMint
        - event: Burn(indexed address,uint256,uint256,indexed address)
          handler: onBurn
        - event: Collect(indexed address,uint256,uint256)
          handler: onCollect
        - event: Sync(uint256,uint256)
          handler: onSync
        - event: Swap(indexed address,indexed address,indexed address,uint256,uint256)
          handler: onSwap
  - kind: ethereum/contract
    name: HybridPool
    network: kovan
    source:
      abi: HybridPool
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/mappings/hybrid-pool.ts
      entities:
        - User
      abis:
        - name: HybridPool
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/HybridPool.sol/HybridPool.json
        - name: HybridPoolFactory
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/HybridPoolFactory.sol/HybridPoolFactory.json
      eventHandlers:
        - event: Mint(indexed address,uint256,uint256,indexed address)
          handler: onMint
        - event: Burn(indexed address,uint256,uint256,indexed address)
          handler: onBurn
        - event: Sync(uint256,uint256)
          handler: onSync
        - event: Swap(indexed address,indexed address,indexed address,uint256,uint256)
          handler: onSwap
        - event: Approval(indexed address,indexed address,uint256)
          handler: onApproval
        - event: Transfer(indexed address,indexed address,uint256)
          handler: onTransfer
  - kind: ethereum/contract
    name: IndexPool
    network: kovan
    source:
      abi: IndexPool
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/mappings/index-pool.ts
      entities:
        - User
      abis:
        - name: IndexPool
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/IndexPool.sol/IndexPool.json
        - name: IndexPoolFactory
          file: ../../node_modules/@sushiswap/trident/artifacts/contracts/pool/IndexPoolFactory.sol/IndexPoolFactory.json
      eventHandlers:
        - event: Mint(indexed address,address,uint256,indexed address)
          handler: onMint
        - event: Burn(indexed address,address,uint256,indexed address)
          handler: onBurn
        - event: Swap(indexed address,indexed address,indexed address,uint256,uint256)
          handler: onSwap
        - event: Approval(indexed address,indexed address,uint256)
          handler: onApproval
        - event: Transfer(indexed address,indexed address,uint256)
          handler: onTransfer
`,
	GraphQLSchema: `enum Fee {
  DEFAULT
}

enum PoolTemplate {
  CONSTANT_PRODUCT
  HYBRID
  INDEX
  CONCENTRATED_LIQUDITY
}

enum Tracking {
  TRACKED
  UNTRACKED
}

enum UntrackedReason {
  LOW_LIQUDITY
  INVALID_TOKEN
}

interface Factory {
  id: ID!
  masterDeployer: MasterDeployer!
  pools: [Pool!]! @derivedFrom(field: "factory")
  poolCount: BigInt!
  transactionCount: BigInt!
}

interface Pool {
  id: ID!
  masterDeployer: MasterDeployer!
  factory: Factory!
  # template: PoolTemplate!
}

type Price @entity {
  id: ID!
  priceUSD: BigDecimal!
}

type MasterDeployer @entity {
  id: ID!
  pendingOwner: Bytes!
  previousOwner: Bytes!
  owner: Bytes!
  migrator: Bytes!
  barFee: BigInt!
  barFeeTo: Bytes!
  bento: Bytes!
  factories: [Factory!]! @derivedFrom(field: "masterDeployer")
  factoryCount: BigInt!
  pools: [Pool!]! @derivedFrom(field: "masterDeployer")
  poolCount: BigInt!
}

type WhitelistedFactory @entity {
  id: ID!
  masterDeployer: MasterDeployer!
}

type ConstantProductPoolFactory implements Factory @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  pools: [Pool!]! @derivedFrom(field: "factory")
  poolCount: BigInt!
  transactionCount: BigInt!
}

type ConstantProductPool implements Pool @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  factory: Factory!
  # template: PoolTemplate!
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigInt!
  transactionCount: BigInt!
  liquidity: BigDecimal!
  # liquidityUSD: BigDecimal!
  volume: BigDecimal!
  # volumeUSD: BigDecimal!
}

type ConcentratedLiquidityPoolFactory implements Factory @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  pools: [Pool!]! @derivedFrom(field: "factory")
  poolCount: BigInt!
  transactionCount: BigInt!
}

type ConcentratedLiquidityPool implements Pool @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  factory: Factory!
  # template: PoolTemplate!
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigInt!
  transactionCount: BigInt!
  liquidity: BigDecimal!
  # liquidityUSD: BigDecimal!
  volume: BigDecimal!
  # volumeUSD: BigDecimal!
}

type HybridPoolFactory implements Factory @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  pools: [Pool!]! @derivedFrom(field: "factory")
  poolCount: BigInt!
  transactionCount: BigInt!
}

type HybridPool implements Pool @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  factory: Factory!
  token0: Token!
  token1: Token!
  token0PrecisionMultiplier: BigInt!
  token1PrecisionMultiplier: BigInt!
  reserve0: BigInt!
  reserve1: BigInt!
  totalSupply: BigInt!
  transactionCount: BigInt!
  liquidity: BigDecimal!
  volume: BigDecimal!
}

type IndexPoolFactory implements Factory @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  pools: [Pool!]! @derivedFrom(field: "factory")
  poolCount: BigInt!
  transactionCount: BigInt!
}

type IndexPool implements Pool @entity {
  id: ID!
  masterDeployer: MasterDeployer!
  factory: Factory!
  token0: Token!
  token1: Token!
  reserve0: BigInt!
  reserve1: BigInt!
  totalSupply: BigInt!
  transactionCount: BigInt!
  liquidity: BigDecimal!
  volume: BigDecimal!
}

type Token @entity {
  id: ID!
  symbol: String!
  symbolSuccess: Boolean!
  name: String!
  nameSuccess: Boolean!
  decimals: BigInt!
  decimalsSuccess: Boolean!
  transactionCount: BigInt!
  liquidity: BigDecimal!
}

type Mint @entity {
  id: ID!
  pool: Pool!
  transaction: Transaction!
  token0: Token!
  token1: Token!
  amount: BigInt!
  amount0: BigDecimal!
  amount1: BigDecimal!
  sender: Bytes!
  recipient: Bytes!
  logIndex: BigInt!
}

type Burn @entity {
  id: ID!
  pool: Pool!
  transaction: Transaction!
  token0: Token!
  token1: Token!
  amount: BigInt!
  amount0: BigDecimal!
  amount1: BigDecimal!
  sender: Bytes!
  recipient: Bytes!
  logIndex: BigInt!
}

type Swap @entity {
  id: ID!
  pool: Pool!
  transaction: Transaction!
  tokenIn: Token!
  tokenOut: Token!
  amountIn: BigDecimal!
  amountOut: BigDecimal!
  recipient: Bytes!
  logIndex: BigInt!
}

type Transaction @entity {
  id: ID!
  gasUsed: BigInt!
  gasLimit: BigInt!
  gasPrice: BigInt!
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
  block: BigInt!
  timestamp: BigInt!
}
`,
	Abis: map[string]string{
		"ConcentratedLiquidityPool": `[
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      },
      {
        "internalType": "contract IMasterDeployer",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      }
    ],
    "name": "Collect",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenIn",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenOut",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "reserveShares0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "reserveShares1",
        "type": "uint256"
      }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "barFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFeeTo",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bento",
    "outputs": [
      {
        "internalType": "contract IBentoBoxMinimal",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burn",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "internalType": "struct IPool.TokenAmount[]",
        "name": "withdrawnAmounts",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "burnSingle",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "collect",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amount0fees",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount1fees",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "collectProtocolFee",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "amount0",
        "type": "uint128"
      },
      {
        "internalType": "uint128",
        "name": "amount1",
        "type": "uint128"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "feeGrowthGlobal0",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "feeGrowthGlobal1",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "flashSwap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "getAmountOut",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "finalAmountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAssets",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "assets",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "_reserve0",
        "type": "uint128"
      },
      {
        "internalType": "uint128",
        "name": "_reserve1",
        "type": "uint128"
      },
      {
        "internalType": "uint32",
        "name": "_lastObservation",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "lastObservation",
    "outputs": [
      {
        "internalType": "uint32",
        "name": "",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "liquidity",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "contract IMasterDeployer",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "mint",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "_liquidity",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "nearestTick",
    "outputs": [
      {
        "internalType": "int24",
        "name": "",
        "type": "int24"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "poolIdentifier",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "int24",
        "name": "",
        "type": "int24"
      },
      {
        "internalType": "int24",
        "name": "",
        "type": "int24"
      }
    ],
    "name": "positions",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "liquidity",
        "type": "uint128"
      },
      {
        "internalType": "uint256",
        "name": "feeGrowthInside0Last",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "feeGrowthInside1Last",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price",
    "outputs": [
      {
        "internalType": "uint160",
        "name": "",
        "type": "uint160"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "int24",
        "name": "lowerTick",
        "type": "int24"
      },
      {
        "internalType": "int24",
        "name": "upperTick",
        "type": "int24"
      }
    ],
    "name": "rangeFeeGrowth",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "feeGrowthInside0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "feeGrowthInside1",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "int24",
        "name": "lowerTick",
        "type": "int24"
      },
      {
        "internalType": "int24",
        "name": "upperTick",
        "type": "int24"
      }
    ],
    "name": "rangeSecondsInside",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "secondsInside",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "reserve0",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "reserve1",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "secondsPerLiquidity",
    "outputs": [
      {
        "internalType": "uint160",
        "name": "",
        "type": "uint160"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "swap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "swapFee",
    "outputs": [
      {
        "internalType": "uint24",
        "name": "",
        "type": "uint24"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "tickSpacing",
    "outputs": [
      {
        "internalType": "uint24",
        "name": "",
        "type": "uint24"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "int24",
        "name": "",
        "type": "int24"
      }
    ],
    "name": "ticks",
    "outputs": [
      {
        "internalType": "int24",
        "name": "previousTick",
        "type": "int24"
      },
      {
        "internalType": "int24",
        "name": "nextTick",
        "type": "int24"
      },
      {
        "internalType": "uint128",
        "name": "liquidity",
        "type": "uint128"
      },
      {
        "internalType": "uint256",
        "name": "feeGrowthOutside0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "feeGrowthOutside1",
        "type": "uint256"
      },
      {
        "internalType": "uint160",
        "name": "secondsPerLiquidityOutside",
        "type": "uint160"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token0ProtocolFee",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1ProtocolFee",
    "outputs": [
      {
        "internalType": "uint128",
        "name": "",
        "type": "uint128"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "updateBarFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]`,
		"ConcentratedLiquidityPoolFactory": `[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "configAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      }
    ],
    "name": "deployPool",
    "outputs": [
      {
        "internalType": "address",
        "name": "pool",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "startIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endIndex",
        "type": "uint256"
      }
    ],
    "name": "getPools",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "pairPools",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "pools",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      }
    ],
    "name": "poolsCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "count",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]`,
		"ConstantProductPool": `[
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      },
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenIn",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenOut",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "reserve0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "reserve1",
        "type": "uint256"
      }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFeeTo",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bento",
    "outputs": [
      {
        "internalType": "contract IBentoBoxMinimal",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burn",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "internalType": "struct IPool.TokenAmount[]",
        "name": "withdrawnAmounts",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burnSingle",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "flashSwap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "getAmountOut",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "finalAmountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAssets",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "assets",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "uint112",
        "name": "_reserve0",
        "type": "uint112"
      },
      {
        "internalType": "uint112",
        "name": "_reserve1",
        "type": "uint112"
      },
      {
        "internalType": "uint32",
        "name": "_blockTimestampLast",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "kLast",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "contract IMasterDeployer",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "mint",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "liquidity",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "poolIdentifier",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price0CumulativeLast",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "price1CumulativeLast",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "swap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "swapFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "updateBarFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]`,
		"ConstantProductPoolFactory": `[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "configAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      }
    ],
    "name": "deployPool",
    "outputs": [
      {
        "internalType": "address",
        "name": "pool",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "startIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endIndex",
        "type": "uint256"
      }
    ],
    "name": "getPools",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "pairPools",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "pools",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      }
    ],
    "name": "poolsCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "count",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]`,
		"ERC20": `[
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_spender",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_from",
        "type": "address"
      },
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "name": "",
        "type": "uint8"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "name": "balance",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      },
      {
        "name": "_spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "payable": true,
    "stateMutability": "payable",
    "type": "fallback"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  }
]`,
		"HybridPool": `[
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      },
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount1",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenIn",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenOut",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "reserve0",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "reserve1",
        "type": "uint256"
      }
    ],
    "name": "Sync",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "A",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFeeTo",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bento",
    "outputs": [
      {
        "internalType": "contract IBentoBoxMinimal",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burn",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "internalType": "struct IPool.TokenAmount[]",
        "name": "withdrawnAmounts",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burnSingle",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "flashSwap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "getAmountOut",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "finalAmountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAssets",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "assets",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "_reserve0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_reserve1",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getVirtualPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "virtualPrice",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "contract IMasterDeployer",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "mint",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "liquidity",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "poolIdentifier",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "swap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "swapFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token0",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token0PrecisionMultiplier",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token1PrecisionMultiplier",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "updateBarFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]`,
		"HybridPoolFactory": `[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "configAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      }
    ],
    "name": "deployPool",
    "outputs": [
      {
        "internalType": "address",
        "name": "pool",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "startIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endIndex",
        "type": "uint256"
      }
    ],
    "name": "getPools",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "pairPools",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "pools",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      }
    ],
    "name": "poolsCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "count",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]`,
		"IndexPool": `[
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      },
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "tokenOut",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Burn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "tokenIn",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenIn",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "tokenOut",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "name": "Swap",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PERMIT_TYPEHASH",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFeeTo",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bento",
    "outputs": [
      {
        "internalType": "contract IBentoBoxMinimal",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burn",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "internalType": "struct IPool.TokenAmount[]",
        "name": "withdrawnAmounts",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "burnSingle",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "flashSwap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "getAmountOut",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAssets",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "assets",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReservesAndWeights",
    "outputs": [
      {
        "internalType": "uint256[]",
        "name": "reserves",
        "type": "uint256[]"
      },
      {
        "internalType": "uint136[]",
        "name": "weights",
        "type": "uint136[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "contract IMasterDeployer",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "mint",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "liquidity",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "poolIdentifier",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "records",
    "outputs": [
      {
        "internalType": "uint120",
        "name": "reserve",
        "type": "uint120"
      },
      {
        "internalType": "uint136",
        "name": "weight",
        "type": "uint136"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "swap",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "swapFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "updateBarFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]`,
		"IndexPoolFactory": `[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_masterDeployer",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "configAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      }
    ],
    "name": "deployPool",
    "outputs": [
      {
        "internalType": "address",
        "name": "pool",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "startIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endIndex",
        "type": "uint256"
      }
    ],
    "name": "getPools",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "pairPools",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "masterDeployer",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "pools",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token1",
        "type": "address"
      }
    ],
    "name": "poolsCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "count",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]`,
		"MasterDeployer": `[
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_barFee",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "_barFeeTo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_bento",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "_factory",
        "type": "address"
      }
    ],
    "name": "AddToWhitelist",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "_barFee",
        "type": "uint256"
      }
    ],
    "name": "BarFeeUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "_factory",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "pool",
        "type": "address"
      }
    ],
    "name": "DeployPool",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "_migrator",
        "type": "address"
      }
    ],
    "name": "MigratorUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "_factory",
        "type": "address"
      }
    ],
    "name": "RemoveFromWhitelist",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "TransferOwner",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      }
    ],
    "name": "TransferOwnerClaim",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_factory",
        "type": "address"
      }
    ],
    "name": "addToWhitelist",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "barFeeTo",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bento",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimOwner",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_factory",
        "type": "address"
      },
      {
        "internalType": "bytes",
        "name": "_deployData",
        "type": "bytes"
      }
    ],
    "name": "deployPool",
    "outputs": [
      {
        "internalType": "address",
        "name": "pool",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "migrator",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "pendingOwner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "pools",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_factory",
        "type": "address"
      }
    ],
    "name": "removeFromWhitelist",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_barFee",
        "type": "uint256"
      }
    ],
    "name": "setBarFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_migrator",
        "type": "address"
      }
    ],
    "name": "setMigrator",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "direct",
        "type": "bool"
      }
    ],
    "name": "transferOwner",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "whitelistedFactories",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]`,
		"NameBytes32": `[
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]`,
		"SymbolBytes32": `[
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]`,
	},
	New: func(base subgraph.Base) subgraph.Subgraph {
		return &Subgraph{
			Base:               base,
			DynamicDataSources: map[string]*DynamicDataSourceXXX{},
		}
	},
	MergeFunc: func(step int, cached, new entity.Interface) entity.Interface {
		switch new.(type) {
		case interface {
			Merge(step int, new *Price)
		}:
			var c *Price
			if cached == nil {
				return new.(*Price)
			}
			c = cached.(*Price)
			el := new.(*Price)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *MasterDeployer)
		}:
			var c *MasterDeployer
			if cached == nil {
				return new.(*MasterDeployer)
			}
			c = cached.(*MasterDeployer)
			el := new.(*MasterDeployer)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *WhitelistedFactory)
		}:
			var c *WhitelistedFactory
			if cached == nil {
				return new.(*WhitelistedFactory)
			}
			c = cached.(*WhitelistedFactory)
			el := new.(*WhitelistedFactory)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *ConstantProductPoolFactory)
		}:
			var c *ConstantProductPoolFactory
			if cached == nil {
				return new.(*ConstantProductPoolFactory)
			}
			c = cached.(*ConstantProductPoolFactory)
			el := new.(*ConstantProductPoolFactory)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *ConstantProductPool)
		}:
			var c *ConstantProductPool
			if cached == nil {
				return new.(*ConstantProductPool)
			}
			c = cached.(*ConstantProductPool)
			el := new.(*ConstantProductPool)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *ConcentratedLiquidityPoolFactory)
		}:
			var c *ConcentratedLiquidityPoolFactory
			if cached == nil {
				return new.(*ConcentratedLiquidityPoolFactory)
			}
			c = cached.(*ConcentratedLiquidityPoolFactory)
			el := new.(*ConcentratedLiquidityPoolFactory)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *ConcentratedLiquidityPool)
		}:
			var c *ConcentratedLiquidityPool
			if cached == nil {
				return new.(*ConcentratedLiquidityPool)
			}
			c = cached.(*ConcentratedLiquidityPool)
			el := new.(*ConcentratedLiquidityPool)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *HybridPoolFactory)
		}:
			var c *HybridPoolFactory
			if cached == nil {
				return new.(*HybridPoolFactory)
			}
			c = cached.(*HybridPoolFactory)
			el := new.(*HybridPoolFactory)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *HybridPool)
		}:
			var c *HybridPool
			if cached == nil {
				return new.(*HybridPool)
			}
			c = cached.(*HybridPool)
			el := new.(*HybridPool)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *IndexPoolFactory)
		}:
			var c *IndexPoolFactory
			if cached == nil {
				return new.(*IndexPoolFactory)
			}
			c = cached.(*IndexPoolFactory)
			el := new.(*IndexPoolFactory)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *IndexPool)
		}:
			var c *IndexPool
			if cached == nil {
				return new.(*IndexPool)
			}
			c = cached.(*IndexPool)
			el := new.(*IndexPool)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *Token)
		}:
			var c *Token
			if cached == nil {
				return new.(*Token)
			}
			c = cached.(*Token)
			el := new.(*Token)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *Mint)
		}:
			var c *Mint
			if cached == nil {
				return new.(*Mint)
			}
			c = cached.(*Mint)
			el := new.(*Mint)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *Burn)
		}:
			var c *Burn
			if cached == nil {
				return new.(*Burn)
			}
			c = cached.(*Burn)
			el := new.(*Burn)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *Swap)
		}:
			var c *Swap
			if cached == nil {
				return new.(*Swap)
			}
			c = cached.(*Swap)
			el := new.(*Swap)
			el.Merge(step, c)
			return el
		case interface {
			Merge(step int, new *Transaction)
		}:
			var c *Transaction
			if cached == nil {
				return new.(*Transaction)
			}
			c = cached.(*Transaction)
			el := new.(*Transaction)
			el.Merge(step, c)
			return el
		case *DynamicDataSourceXXX:
			return new
		}
		panic("unsupported merge type")
	},
}

type Subgraph struct {
	subgraph.Base

	CurrentBlockDynamicDataSources map[string]*DynamicDataSourceXXX
	DynamicDataSources             map[string]*DynamicDataSourceXXX
}

var (
	FeeDEFAULT = entity.Enum("DEFAULT")
)

var (
	PoolTemplateCONSTANTPRODUCT      = entity.Enum("CONSTANTPRODUCT")
	PoolTemplateHYBRID               = entity.Enum("HYBRID")
	PoolTemplateINDEX                = entity.Enum("INDEX")
	PoolTemplateCONCENTRATEDLIQUDITY = entity.Enum("CONCENTRATEDLIQUDITY")
)

var (
	TrackingTRACKED   = entity.Enum("TRACKED")
	TrackingUNTRACKED = entity.Enum("UNTRACKED")
)

var (
	UntrackedReasonLOWLIQUDITY  = entity.Enum("LOWLIQUDITY")
	UntrackedReasonINVALIDTOKEN = entity.Enum("INVALIDTOKEN")
)

// Price
type Price struct {
	entity.Base
	PriceUSD entity.Float `db:"price_usd" csv:"price_usd"`
}

func NewPrice(id string) *Price {
	return &Price{
		Base:     entity.NewBase(id),
		PriceUSD: FL(0),
	}
}

func (_ *Price) SkipDBLookup() bool {
	return false
}

// MasterDeployer
type MasterDeployer struct {
	entity.Base
	PendingOwner  entity.Bytes `db:"pending_owner" csv:"pending_owner"`
	PreviousOwner entity.Bytes `db:"previous_owner" csv:"previous_owner"`
	Owner         entity.Bytes `db:"owner" csv:"owner"`
	Migrator      entity.Bytes `db:"migrator" csv:"migrator"`
	BarFee        entity.Int   `db:"bar_fee" csv:"bar_fee"`
	BarFeeTo      entity.Bytes `db:"bar_fee_to" csv:"bar_fee_to"`
	Bento         entity.Bytes `db:"bento" csv:"bento"`
	FactoryCount  entity.Int   `db:"factory_count" csv:"factory_count"`
	PoolCount     entity.Int   `db:"pool_count" csv:"pool_count"`
}

func NewMasterDeployer(id string) *MasterDeployer {
	return &MasterDeployer{
		Base:          entity.NewBase(id),
		PendingOwner:  []byte{},
		PreviousOwner: []byte{},
		Owner:         []byte{},
		Migrator:      []byte{},
		BarFee:        IL(0),
		BarFeeTo:      []byte{},
		Bento:         []byte{},
		FactoryCount:  IL(0),
		PoolCount:     IL(0),
	}
}

func (_ *MasterDeployer) SkipDBLookup() bool {
	return false
}

// WhitelistedFactory
type WhitelistedFactory struct {
	entity.Base
	MasterDeployer string `db:"master_deployer" csv:"master_deployer"`
}

func NewWhitelistedFactory(id string) *WhitelistedFactory {
	return &WhitelistedFactory{
		Base: entity.NewBase(id),
	}
}

func (_ *WhitelistedFactory) SkipDBLookup() bool {
	return false
}

// ConstantProductPoolFactory
type ConstantProductPoolFactory struct {
	entity.Base
	MasterDeployer   string     `db:"master_deployer" csv:"master_deployer"`
	PoolCount        entity.Int `db:"pool_count" csv:"pool_count"`
	TransactionCount entity.Int `db:"transaction_count" csv:"transaction_count"`
}

func NewConstantProductPoolFactory(id string) *ConstantProductPoolFactory {
	return &ConstantProductPoolFactory{
		Base:             entity.NewBase(id),
		PoolCount:        IL(0),
		TransactionCount: IL(0),
	}
}

func (_ *ConstantProductPoolFactory) SkipDBLookup() bool {
	return false
}

// ConstantProductPool
type ConstantProductPool struct {
	entity.Base
	MasterDeployer   string       `db:"master_deployer" csv:"master_deployer"`
	Factory          string       `db:"factory" csv:"factory"`
	Token0           string       `db:"token_0" csv:"token_0"`
	Token1           string       `db:"token_1" csv:"token_1"`
	Reserve0         entity.Float `db:"reserve_0" csv:"reserve_0"`
	Reserve1         entity.Float `db:"reserve_1" csv:"reserve_1"`
	TotalSupply      entity.Int   `db:"total_supply" csv:"total_supply"`
	TransactionCount entity.Int   `db:"transaction_count" csv:"transaction_count"`
	TotalValueLocked entity.Float `db:"total_value_locked" csv:"total_value_locked"`
	Volume           entity.Float `db:"volume" csv:"volume"`
}

func NewConstantProductPool(id string) *ConstantProductPool {
	return &ConstantProductPool{
		Base:             entity.NewBase(id),
		Reserve0:         FL(0),
		Reserve1:         FL(0),
		TotalSupply:      IL(0),
		TransactionCount: IL(0),
		TotalValueLocked: FL(0),
		Volume:           FL(0),
	}
}

func (_ *ConstantProductPool) SkipDBLookup() bool {
	return false
}

// ConcentratedLiquidityPoolFactory
type ConcentratedLiquidityPoolFactory struct {
	entity.Base
	MasterDeployer   string     `db:"master_deployer" csv:"master_deployer"`
	PoolCount        entity.Int `db:"pool_count" csv:"pool_count"`
	TransactionCount entity.Int `db:"transaction_count" csv:"transaction_count"`
}

func NewConcentratedLiquidityPoolFactory(id string) *ConcentratedLiquidityPoolFactory {
	return &ConcentratedLiquidityPoolFactory{
		Base:             entity.NewBase(id),
		PoolCount:        IL(0),
		TransactionCount: IL(0),
	}
}

func (_ *ConcentratedLiquidityPoolFactory) SkipDBLookup() bool {
	return false
}

// ConcentratedLiquidityPool
type ConcentratedLiquidityPool struct {
	entity.Base
	MasterDeployer   string       `db:"master_deployer" csv:"master_deployer"`
	Factory          string       `db:"factory" csv:"factory"`
	Token0           string       `db:"token_0" csv:"token_0"`
	Token1           string       `db:"token_1" csv:"token_1"`
	Reserve0         entity.Float `db:"reserve_0" csv:"reserve_0"`
	Reserve1         entity.Float `db:"reserve_1" csv:"reserve_1"`
	TotalSupply      entity.Int   `db:"total_supply" csv:"total_supply"`
	TransactionCount entity.Int   `db:"transaction_count" csv:"transaction_count"`
	TotalValueLocked entity.Float `db:"total_value_locked" csv:"total_value_locked"`
	Volume           entity.Float `db:"volume" csv:"volume"`
}

func NewConcentratedLiquidityPool(id string) *ConcentratedLiquidityPool {
	return &ConcentratedLiquidityPool{
		Base:             entity.NewBase(id),
		Reserve0:         FL(0),
		Reserve1:         FL(0),
		TotalSupply:      IL(0),
		TransactionCount: IL(0),
		TotalValueLocked: FL(0),
		Volume:           FL(0),
	}
}

func (_ *ConcentratedLiquidityPool) SkipDBLookup() bool {
	return false
}

// HybridPoolFactory
type HybridPoolFactory struct {
	entity.Base
	MasterDeployer   string     `db:"master_deployer" csv:"master_deployer"`
	PoolCount        entity.Int `db:"pool_count" csv:"pool_count"`
	TransactionCount entity.Int `db:"transaction_count" csv:"transaction_count"`
}

func NewHybridPoolFactory(id string) *HybridPoolFactory {
	return &HybridPoolFactory{
		Base:             entity.NewBase(id),
		PoolCount:        IL(0),
		TransactionCount: IL(0),
	}
}

func (_ *HybridPoolFactory) SkipDBLookup() bool {
	return false
}

// HybridPool
type HybridPool struct {
	entity.Base
	MasterDeployer            string       `db:"master_deployer" csv:"master_deployer"`
	Factory                   string       `db:"factory" csv:"factory"`
	Token0                    string       `db:"token_0" csv:"token_0"`
	Token1                    string       `db:"token_1" csv:"token_1"`
	Token0PrecisionMultiplier entity.Int   `db:"token_0_precision_multiplier" csv:"token_0_precision_multiplier"`
	Token1PrecisionMultiplier entity.Int   `db:"token_1_precision_multiplier" csv:"token_1_precision_multiplier"`
	Reserve0                  entity.Int   `db:"reserve_0" csv:"reserve_0"`
	Reserve1                  entity.Int   `db:"reserve_1" csv:"reserve_1"`
	TotalSupply               entity.Int   `db:"total_supply" csv:"total_supply"`
	TransactionCount          entity.Int   `db:"transaction_count" csv:"transaction_count"`
	TotalValueLocked          entity.Float `db:"total_value_locked" csv:"total_value_locked"`
	Volume                    entity.Float `db:"volume" csv:"volume"`
}

func NewHybridPool(id string) *HybridPool {
	return &HybridPool{
		Base:                      entity.NewBase(id),
		Token0PrecisionMultiplier: IL(0),
		Token1PrecisionMultiplier: IL(0),
		Reserve0:                  IL(0),
		Reserve1:                  IL(0),
		TotalSupply:               IL(0),
		TransactionCount:          IL(0),
		TotalValueLocked:          FL(0),
		Volume:                    FL(0),
	}
}

func (_ *HybridPool) SkipDBLookup() bool {
	return false
}

// IndexPoolFactory
type IndexPoolFactory struct {
	entity.Base
	MasterDeployer   string     `db:"master_deployer" csv:"master_deployer"`
	PoolCount        entity.Int `db:"pool_count" csv:"pool_count"`
	TransactionCount entity.Int `db:"transaction_count" csv:"transaction_count"`
}

func NewIndexPoolFactory(id string) *IndexPoolFactory {
	return &IndexPoolFactory{
		Base:             entity.NewBase(id),
		PoolCount:        IL(0),
		TransactionCount: IL(0),
	}
}

func (_ *IndexPoolFactory) SkipDBLookup() bool {
	return false
}

// IndexPool
type IndexPool struct {
	entity.Base
	MasterDeployer   string       `db:"master_deployer" csv:"master_deployer"`
	Factory          string       `db:"factory" csv:"factory"`
	Token0           string       `db:"token_0" csv:"token_0"`
	Token1           string       `db:"token_1" csv:"token_1"`
	Reserve0         entity.Int   `db:"reserve_0" csv:"reserve_0"`
	Reserve1         entity.Int   `db:"reserve_1" csv:"reserve_1"`
	TotalSupply      entity.Int   `db:"total_supply" csv:"total_supply"`
	TransactionCount entity.Int   `db:"transaction_count" csv:"transaction_count"`
	TotalValueLocked entity.Float `db:"total_value_locked" csv:"total_value_locked"`
	Volume           entity.Float `db:"volume" csv:"volume"`
}

func NewIndexPool(id string) *IndexPool {
	return &IndexPool{
		Base:             entity.NewBase(id),
		Reserve0:         IL(0),
		Reserve1:         IL(0),
		TotalSupply:      IL(0),
		TransactionCount: IL(0),
		TotalValueLocked: FL(0),
		Volume:           FL(0),
	}
}

func (_ *IndexPool) SkipDBLookup() bool {
	return false
}

// Token
type Token struct {
	entity.Base
	Symbol           string       `db:"symbol" csv:"symbol"`
	SymbolSuccess    entity.Bool  `db:"symbol_success" csv:"symbol_success"`
	Name             string       `db:"name" csv:"name"`
	NameSuccess      entity.Bool  `db:"name_success" csv:"name_success"`
	Decimals         entity.Int   `db:"decimals" csv:"decimals"`
	DecimalsSuccess  entity.Bool  `db:"decimals_success" csv:"decimals_success"`
	TransactionCount entity.Int   `db:"transaction_count" csv:"transaction_count"`
	TotalValueLocked entity.Float `db:"total_value_locked" csv:"total_value_locked"`
}

func NewToken(id string) *Token {
	return &Token{
		Base:             entity.NewBase(id),
		Decimals:         IL(0),
		TransactionCount: IL(0),
		TotalValueLocked: FL(0),
	}
}

func (_ *Token) SkipDBLookup() bool {
	return false
}

// Mint
type Mint struct {
	entity.Base
	Pool        string       `db:"pool" csv:"pool"`
	Transaction string       `db:"transaction" csv:"transaction"`
	Token0      string       `db:"token_0" csv:"token_0"`
	Token1      string       `db:"token_1" csv:"token_1"`
	Amount      entity.Int   `db:"amount" csv:"amount"`
	Amount0     entity.Float `db:"amount_0" csv:"amount_0"`
	Amount1     entity.Float `db:"amount_1" csv:"amount_1"`
	Sender      entity.Bytes `db:"sender" csv:"sender"`
	Recipient   entity.Bytes `db:"recipient" csv:"recipient"`
	LogIndex    entity.Int   `db:"log_index" csv:"log_index"`
}

func NewMint(id string) *Mint {
	return &Mint{
		Base:      entity.NewBase(id),
		Amount:    IL(0),
		Amount0:   FL(0),
		Amount1:   FL(0),
		Sender:    []byte{},
		Recipient: []byte{},
		LogIndex:  IL(0),
	}
}

func (_ *Mint) SkipDBLookup() bool {
	return false
}

// Burn
type Burn struct {
	entity.Base
	Pool        string       `db:"pool" csv:"pool"`
	Transaction string       `db:"transaction" csv:"transaction"`
	Token0      string       `db:"token_0" csv:"token_0"`
	Token1      string       `db:"token_1" csv:"token_1"`
	Amount      entity.Int   `db:"amount" csv:"amount"`
	Amount0     entity.Float `db:"amount_0" csv:"amount_0"`
	Amount1     entity.Float `db:"amount_1" csv:"amount_1"`
	Sender      entity.Bytes `db:"sender" csv:"sender"`
	Recipient   entity.Bytes `db:"recipient" csv:"recipient"`
	LogIndex    entity.Int   `db:"log_index" csv:"log_index"`
}

func NewBurn(id string) *Burn {
	return &Burn{
		Base:      entity.NewBase(id),
		Amount:    IL(0),
		Amount0:   FL(0),
		Amount1:   FL(0),
		Sender:    []byte{},
		Recipient: []byte{},
		LogIndex:  IL(0),
	}
}

func (_ *Burn) SkipDBLookup() bool {
	return false
}

// Swap
type Swap struct {
	entity.Base
	Pool        string       `db:"pool" csv:"pool"`
	Transaction string       `db:"transaction" csv:"transaction"`
	TokenIn     string       `db:"token_in" csv:"token_in"`
	TokenOut    string       `db:"token_out" csv:"token_out"`
	AmountIn    entity.Float `db:"amount_in" csv:"amount_in"`
	AmountOut   entity.Float `db:"amount_out" csv:"amount_out"`
	Recipient   entity.Bytes `db:"recipient" csv:"recipient"`
	LogIndex    entity.Int   `db:"log_index" csv:"log_index"`
}

func NewSwap(id string) *Swap {
	return &Swap{
		Base:      entity.NewBase(id),
		AmountIn:  FL(0),
		AmountOut: FL(0),
		Recipient: []byte{},
		LogIndex:  IL(0),
	}
}

func (_ *Swap) SkipDBLookup() bool {
	return false
}

// Transaction
type Transaction struct {
	entity.Base
	GasUsed   entity.Int `db:"gas_used" csv:"gas_used"`
	GasLimit  entity.Int `db:"gas_limit" csv:"gas_limit"`
	GasPrice  entity.Int `db:"gas_price" csv:"gas_price"`
	Block     entity.Int `db:"block" csv:"block"`
	Timestamp entity.Int `db:"timestamp" csv:"timestamp"`
}

func NewTransaction(id string) *Transaction {
	return &Transaction{
		Base:      entity.NewBase(id),
		GasUsed:   IL(0),
		GasLimit:  IL(0),
		GasPrice:  IL(0),
		Block:     IL(0),
		Timestamp: IL(0),
	}
}

func (_ *Transaction) SkipDBLookup() bool {
	return false
}

func (s *Subgraph) HandleBlock(block *pbcodec.Block) error {
	idx := uint32(0)
	s.CurrentBlockDynamicDataSources = make(map[string]*DynamicDataSourceXXX)

	for _, trace := range block.TransactionTraces {
		logs := trace.Logs()
		for _, log := range logs {
			var ethLog interface{} = log
			eventLog := codecLogToEthLog(ethLog.(*pbcodec.Log), idx)
			idx++
			if bytes.Equal(FactoryAddressBytes, log.Address) || s.IsDynamicDataSource(eth.Address(log.Address).Pretty()) {
				ev, err := DecodeEvent(eventLog, block, trace)
				if err != nil {
					return fmt.Errorf("parsing event: %w", err)
				}
				if err := s.HandleEvent(ev); err != nil {
					return fmt.Errorf("handling event: %w", err)
				}

			}
		}
	}

	if len(s.CurrentBlockDynamicDataSources) == 0 {
		return nil
	}

	for _, trace := range block.TransactionTraces {
		logs := trace.Logs()
		for _, log := range logs {
			var ethLog interface{} = log
			eventLog := codecLogToEthLog(ethLog.(*pbcodec.Log), idx)
			idx++
			if s.IsCurrentDynamicDataSource(eth.Address(log.Address).Pretty()) {
				ev, err := DecodeEvent(eventLog, block, trace)
				if err != nil {
					return fmt.Errorf("parsing event: %w", err)
				}
				if err := s.HandleEvent(ev); err != nil {
					return fmt.Errorf("handling event: %w", err)
				}

			}
		}
	}

	for k, v := range s.CurrentBlockDynamicDataSources {
		s.DynamicDataSources[k] = v
	}

	return nil
}
func (s *Subgraph) HandleEvent(ev interface{}) error {
	switch e := ev.(type) {

	case *MasterDeployerAddToWhitelistEvent:
		if err := s.HandleMasterDeployerAddToWhitelistEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerAddToWhitelist event: %w", err)
		}
	case *MasterDeployerBarFeeUpdatedEvent:
		if err := s.HandleMasterDeployerBarFeeUpdatedEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerBarFeeUpdated event: %w", err)
		}
	case *MasterDeployerDeployPoolEvent:
		if err := s.HandleMasterDeployerDeployPoolEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerDeployPool event: %w", err)
		}
	case *MasterDeployerMigratorUpdatedEvent:
		if err := s.HandleMasterDeployerMigratorUpdatedEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerMigratorUpdated event: %w", err)
		}
	case *MasterDeployerRemoveFromWhitelistEvent:
		if err := s.HandleMasterDeployerRemoveFromWhitelistEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerRemoveFromWhitelist event: %w", err)
		}
	case *MasterDeployerTransferOwnerEvent:
		if err := s.HandleMasterDeployerTransferOwnerEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerTransferOwner event: %w", err)
		}
	case *MasterDeployerTransferOwnerClaimEvent:
		if err := s.HandleMasterDeployerTransferOwnerClaimEvent(e); err != nil {
			return fmt.Errorf("handling MasterDeployerTransferOwnerClaim event: %w", err)
		}

	case *ConstantProductPoolApprovalEvent:
		if err := s.HandleConstantProductPoolApprovalEvent(e); err != nil {
			return fmt.Errorf("handling ConstantProductPoolApproval event: %w", err)
		}
	case *ConstantProductPoolBurnEvent:
		if err := s.HandleConstantProductPoolBurnEvent(e); err != nil {
			return fmt.Errorf("handling ConstantProductPoolBurn event: %w", err)
		}
	case *ConstantProductPoolMintEvent:
		if err := s.HandleConstantProductPoolMintEvent(e); err != nil {
			return fmt.Errorf("handling ConstantProductPoolMint event: %w", err)
		}
	case *ConstantProductPoolSwapEvent:
		if err := s.HandleConstantProductPoolSwapEvent(e); err != nil {
			return fmt.Errorf("handling ConstantProductPoolSwap event: %w", err)
		}
	case *ConstantProductPoolSyncEvent:
		if err := s.HandleConstantProductPoolSyncEvent(e); err != nil {
			return fmt.Errorf("handling ConstantProductPoolSync event: %w", err)
		}
	case *ConstantProductPoolTransferEvent:
		if err := s.HandleConstantProductPoolTransferEvent(e); err != nil {
			return fmt.Errorf("handling ConstantProductPoolTransfer event: %w", err)
		}

	case *ConcentratedLiquidityPoolBurnEvent:
		if err := s.HandleConcentratedLiquidityPoolBurnEvent(e); err != nil {
			return fmt.Errorf("handling ConcentratedLiquidityPoolBurn event: %w", err)
		}
	case *ConcentratedLiquidityPoolCollectEvent:
		if err := s.HandleConcentratedLiquidityPoolCollectEvent(e); err != nil {
			return fmt.Errorf("handling ConcentratedLiquidityPoolCollect event: %w", err)
		}
	case *ConcentratedLiquidityPoolMintEvent:
		if err := s.HandleConcentratedLiquidityPoolMintEvent(e); err != nil {
			return fmt.Errorf("handling ConcentratedLiquidityPoolMint event: %w", err)
		}
	case *ConcentratedLiquidityPoolSwapEvent:
		if err := s.HandleConcentratedLiquidityPoolSwapEvent(e); err != nil {
			return fmt.Errorf("handling ConcentratedLiquidityPoolSwap event: %w", err)
		}
	case *ConcentratedLiquidityPoolSyncEvent:
		if err := s.HandleConcentratedLiquidityPoolSyncEvent(e); err != nil {
			return fmt.Errorf("handling ConcentratedLiquidityPoolSync event: %w", err)
		}

	case *HybridPoolApprovalEvent:
		if err := s.HandleHybridPoolApprovalEvent(e); err != nil {
			return fmt.Errorf("handling HybridPoolApproval event: %w", err)
		}
	case *HybridPoolBurnEvent:
		if err := s.HandleHybridPoolBurnEvent(e); err != nil {
			return fmt.Errorf("handling HybridPoolBurn event: %w", err)
		}
	case *HybridPoolMintEvent:
		if err := s.HandleHybridPoolMintEvent(e); err != nil {
			return fmt.Errorf("handling HybridPoolMint event: %w", err)
		}
	case *HybridPoolSwapEvent:
		if err := s.HandleHybridPoolSwapEvent(e); err != nil {
			return fmt.Errorf("handling HybridPoolSwap event: %w", err)
		}
	case *HybridPoolSyncEvent:
		if err := s.HandleHybridPoolSyncEvent(e); err != nil {
			return fmt.Errorf("handling HybridPoolSync event: %w", err)
		}
	case *HybridPoolTransferEvent:
		if err := s.HandleHybridPoolTransferEvent(e); err != nil {
			return fmt.Errorf("handling HybridPoolTransfer event: %w", err)
		}

	case *IndexPoolApprovalEvent:
		if err := s.HandleIndexPoolApprovalEvent(e); err != nil {
			return fmt.Errorf("handling IndexPoolApproval event: %w", err)
		}
	case *IndexPoolBurnEvent:
		if err := s.HandleIndexPoolBurnEvent(e); err != nil {
			return fmt.Errorf("handling IndexPoolBurn event: %w", err)
		}
	case *IndexPoolMintEvent:
		if err := s.HandleIndexPoolMintEvent(e); err != nil {
			return fmt.Errorf("handling IndexPoolMint event: %w", err)
		}
	case *IndexPoolSwapEvent:
		if err := s.HandleIndexPoolSwapEvent(e); err != nil {
			return fmt.Errorf("handling IndexPoolSwap event: %w", err)
		}
	case *IndexPoolTransferEvent:
		if err := s.HandleIndexPoolTransferEvent(e); err != nil {
			return fmt.Errorf("handling IndexPoolTransfer event: %w", err)
		}
	}

	return nil
}

func codecLogToEthLog(l *pbcodec.Log, idx uint32) *eth.Log {
	return &eth.Log{
		Address:    l.Address,
		Topics:     l.Topics,
		Data:       l.Data,
		Index:      l.Index,
		BlockIndex: idx,
	}
}

// ConcentratedLiquidityPool
// ConcentratedLiquidityPoolBurn event

type ConcentratedLiquidityPoolBurnEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Amount0   *big.Int    `eth:""`
	Amount1   *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashConcentratedLiquidityPoolBurnEvent = eth.Keccak256([]byte("Burn(address,uint256,uint256,address)"))

func IsConcentratedLiquidityPoolBurnEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConcentratedLiquidityPoolBurnEvent)
}

func NewConcentratedLiquidityPoolBurnEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConcentratedLiquidityPoolBurnEvent, error) {
	var err error
	ev := &ConcentratedLiquidityPoolBurnEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// ConcentratedLiquidityPoolCollect event

type ConcentratedLiquidityPoolCollectEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender  eth.Address `eth:",indexed"`
	Amount0 *big.Int    `eth:""`
	Amount1 *big.Int    `eth:""`
}

var hashConcentratedLiquidityPoolCollectEvent = eth.Keccak256([]byte("Collect(address,uint256,uint256)"))

func IsConcentratedLiquidityPoolCollectEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConcentratedLiquidityPoolCollectEvent)
}

func NewConcentratedLiquidityPoolCollectEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConcentratedLiquidityPoolCollectEvent, error) {
	var err error
	ev := &ConcentratedLiquidityPoolCollectEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	return ev, nil
}

// ConcentratedLiquidityPoolMint event

type ConcentratedLiquidityPoolMintEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Amount0   *big.Int    `eth:""`
	Amount1   *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashConcentratedLiquidityPoolMintEvent = eth.Keccak256([]byte("Mint(address,uint256,uint256,address)"))

func IsConcentratedLiquidityPoolMintEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConcentratedLiquidityPoolMintEvent)
}

func NewConcentratedLiquidityPoolMintEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConcentratedLiquidityPoolMintEvent, error) {
	var err error
	ev := &ConcentratedLiquidityPoolMintEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// ConcentratedLiquidityPoolSwap event

type ConcentratedLiquidityPoolSwapEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Recipient eth.Address `eth:",indexed"`
	TokenIn   eth.Address `eth:",indexed"`
	TokenOut  eth.Address `eth:",indexed"`
	AmountIn  *big.Int    `eth:""`
	AmountOut *big.Int    `eth:""`
}

var hashConcentratedLiquidityPoolSwapEvent = eth.Keccak256([]byte("Swap(address,address,address,uint256,uint256)"))

func IsConcentratedLiquidityPoolSwapEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConcentratedLiquidityPoolSwapEvent)
}

func NewConcentratedLiquidityPoolSwapEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConcentratedLiquidityPoolSwapEvent, error) {
	var err error
	ev := &ConcentratedLiquidityPoolSwapEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenIn: %w", err)
	}
	ev.TokenIn = f1.(eth.Address)
	f2, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenOut: %w", err)
	}
	ev.TokenOut = f2.(eth.Address)
	ev.AmountIn, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountIn:  %w", err)
	}
	ev.AmountOut, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountOut:  %w", err)
	}
	return ev, nil
}

// ConcentratedLiquidityPoolSync event

type ConcentratedLiquidityPoolSyncEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	ReserveShares0 *big.Int `eth:""`
	ReserveShares1 *big.Int `eth:""`
}

var hashConcentratedLiquidityPoolSyncEvent = eth.Keccak256([]byte("Sync(uint256,uint256)"))

func IsConcentratedLiquidityPoolSyncEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConcentratedLiquidityPoolSyncEvent)
}

func NewConcentratedLiquidityPoolSyncEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConcentratedLiquidityPoolSyncEvent, error) {
	var err error
	ev := &ConcentratedLiquidityPoolSyncEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.ReserveShares0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserveShares0:  %w", err)
	}
	ev.ReserveShares1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserveShares1:  %w", err)
	}
	return ev, nil
}

// ConstantProductPool
// ConstantProductPoolApproval event

type ConstantProductPoolApprovalEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Owner   eth.Address `eth:",indexed"`
	Spender eth.Address `eth:",indexed"`
	Amount  *big.Int    `eth:""`
}

var hashConstantProductPoolApprovalEvent = eth.Keccak256([]byte("Approval(address,address,uint256)"))

func IsConstantProductPoolApprovalEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConstantProductPoolApprovalEvent)
}

func NewConstantProductPoolApprovalEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConstantProductPoolApprovalEvent, error) {
	var err error
	ev := &ConstantProductPoolApprovalEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading owner: %w", err)
	}
	ev.Owner = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading spender: %w", err)
	}
	ev.Spender = f1.(eth.Address)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// ConstantProductPoolBurn event

type ConstantProductPoolBurnEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Amount0   *big.Int    `eth:""`
	Amount1   *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashConstantProductPoolBurnEvent = eth.Keccak256([]byte("Burn(address,uint256,uint256,address)"))

func IsConstantProductPoolBurnEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConstantProductPoolBurnEvent)
}

func NewConstantProductPoolBurnEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConstantProductPoolBurnEvent, error) {
	var err error
	ev := &ConstantProductPoolBurnEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// ConstantProductPoolMint event

type ConstantProductPoolMintEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Amount0   *big.Int    `eth:""`
	Amount1   *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashConstantProductPoolMintEvent = eth.Keccak256([]byte("Mint(address,uint256,uint256,address)"))

func IsConstantProductPoolMintEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConstantProductPoolMintEvent)
}

func NewConstantProductPoolMintEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConstantProductPoolMintEvent, error) {
	var err error
	ev := &ConstantProductPoolMintEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// ConstantProductPoolSwap event

type ConstantProductPoolSwapEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Recipient eth.Address `eth:",indexed"`
	TokenIn   eth.Address `eth:",indexed"`
	TokenOut  eth.Address `eth:",indexed"`
	AmountIn  *big.Int    `eth:""`
	AmountOut *big.Int    `eth:""`
}

var hashConstantProductPoolSwapEvent = eth.Keccak256([]byte("Swap(address,address,address,uint256,uint256)"))

func IsConstantProductPoolSwapEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConstantProductPoolSwapEvent)
}

func NewConstantProductPoolSwapEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConstantProductPoolSwapEvent, error) {
	var err error
	ev := &ConstantProductPoolSwapEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenIn: %w", err)
	}
	ev.TokenIn = f1.(eth.Address)
	f2, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenOut: %w", err)
	}
	ev.TokenOut = f2.(eth.Address)
	ev.AmountIn, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountIn:  %w", err)
	}
	ev.AmountOut, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountOut:  %w", err)
	}
	return ev, nil
}

// ConstantProductPoolSync event

type ConstantProductPoolSyncEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Reserve0 *big.Int `eth:""`
	Reserve1 *big.Int `eth:""`
}

var hashConstantProductPoolSyncEvent = eth.Keccak256([]byte("Sync(uint256,uint256)"))

func IsConstantProductPoolSyncEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConstantProductPoolSyncEvent)
}

func NewConstantProductPoolSyncEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConstantProductPoolSyncEvent, error) {
	var err error
	ev := &ConstantProductPoolSyncEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Reserve0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserve0:  %w", err)
	}
	ev.Reserve1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserve1:  %w", err)
	}
	return ev, nil
}

// ConstantProductPoolTransfer event

type ConstantProductPoolTransferEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Recipient eth.Address `eth:",indexed"`
	Amount    *big.Int    `eth:""`
}

var hashConstantProductPoolTransferEvent = eth.Keccak256([]byte("Transfer(address,address,uint256)"))

func IsConstantProductPoolTransferEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashConstantProductPoolTransferEvent)
}

func NewConstantProductPoolTransferEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*ConstantProductPoolTransferEvent, error) {
	var err error
	ev := &ConstantProductPoolTransferEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f1.(eth.Address)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// HybridPool
// HybridPoolApproval event

type HybridPoolApprovalEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Owner   eth.Address `eth:",indexed"`
	Spender eth.Address `eth:",indexed"`
	Amount  *big.Int    `eth:""`
}

var hashHybridPoolApprovalEvent = eth.Keccak256([]byte("Approval(address,address,uint256)"))

func IsHybridPoolApprovalEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashHybridPoolApprovalEvent)
}

func NewHybridPoolApprovalEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*HybridPoolApprovalEvent, error) {
	var err error
	ev := &HybridPoolApprovalEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading owner: %w", err)
	}
	ev.Owner = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading spender: %w", err)
	}
	ev.Spender = f1.(eth.Address)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// HybridPoolBurn event

type HybridPoolBurnEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Amount0   *big.Int    `eth:""`
	Amount1   *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashHybridPoolBurnEvent = eth.Keccak256([]byte("Burn(address,uint256,uint256,address)"))

func IsHybridPoolBurnEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashHybridPoolBurnEvent)
}

func NewHybridPoolBurnEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*HybridPoolBurnEvent, error) {
	var err error
	ev := &HybridPoolBurnEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// HybridPoolMint event

type HybridPoolMintEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Amount0   *big.Int    `eth:""`
	Amount1   *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashHybridPoolMintEvent = eth.Keccak256([]byte("Mint(address,uint256,uint256,address)"))

func IsHybridPoolMintEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashHybridPoolMintEvent)
}

func NewHybridPoolMintEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*HybridPoolMintEvent, error) {
	var err error
	ev := &HybridPoolMintEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// HybridPoolSwap event

type HybridPoolSwapEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Recipient eth.Address `eth:",indexed"`
	TokenIn   eth.Address `eth:",indexed"`
	TokenOut  eth.Address `eth:",indexed"`
	AmountIn  *big.Int    `eth:""`
	AmountOut *big.Int    `eth:""`
}

var hashHybridPoolSwapEvent = eth.Keccak256([]byte("Swap(address,address,address,uint256,uint256)"))

func IsHybridPoolSwapEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashHybridPoolSwapEvent)
}

func NewHybridPoolSwapEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*HybridPoolSwapEvent, error) {
	var err error
	ev := &HybridPoolSwapEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenIn: %w", err)
	}
	ev.TokenIn = f1.(eth.Address)
	f2, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenOut: %w", err)
	}
	ev.TokenOut = f2.(eth.Address)
	ev.AmountIn, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountIn:  %w", err)
	}
	ev.AmountOut, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountOut:  %w", err)
	}
	return ev, nil
}

// HybridPoolSync event

type HybridPoolSyncEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Reserve0 *big.Int `eth:""`
	Reserve1 *big.Int `eth:""`
}

var hashHybridPoolSyncEvent = eth.Keccak256([]byte("Sync(uint256,uint256)"))

func IsHybridPoolSyncEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashHybridPoolSyncEvent)
}

func NewHybridPoolSyncEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*HybridPoolSyncEvent, error) {
	var err error
	ev := &HybridPoolSyncEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Reserve0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserve0:  %w", err)
	}
	ev.Reserve1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserve1:  %w", err)
	}
	return ev, nil
}

// HybridPoolTransfer event

type HybridPoolTransferEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Recipient eth.Address `eth:",indexed"`
	Amount    *big.Int    `eth:""`
}

var hashHybridPoolTransferEvent = eth.Keccak256([]byte("Transfer(address,address,uint256)"))

func IsHybridPoolTransferEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashHybridPoolTransferEvent)
}

func NewHybridPoolTransferEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*HybridPoolTransferEvent, error) {
	var err error
	ev := &HybridPoolTransferEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f1.(eth.Address)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// IndexPool
// IndexPoolApproval event

type IndexPoolApprovalEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Owner   eth.Address `eth:",indexed"`
	Spender eth.Address `eth:",indexed"`
	Amount  *big.Int    `eth:""`
}

var hashIndexPoolApprovalEvent = eth.Keccak256([]byte("Approval(address,address,uint256)"))

func IsIndexPoolApprovalEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashIndexPoolApprovalEvent)
}

func NewIndexPoolApprovalEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*IndexPoolApprovalEvent, error) {
	var err error
	ev := &IndexPoolApprovalEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading owner: %w", err)
	}
	ev.Owner = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading spender: %w", err)
	}
	ev.Spender = f1.(eth.Address)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// IndexPoolBurn event

type IndexPoolBurnEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	TokenOut  eth.Address `eth:""`
	AmountOut *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashIndexPoolBurnEvent = eth.Keccak256([]byte("Burn(address,address,uint256,address)"))

func IsIndexPoolBurnEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashIndexPoolBurnEvent)
}

func NewIndexPoolBurnEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*IndexPoolBurnEvent, error) {
	var err error
	ev := &IndexPoolBurnEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.TokenOut, err = dec.DataDecoder.ReadAddress()
	if err != nil {
		return nil, fmt.Errorf("reading tokenOut:  %w", err)
	}
	ev.AmountOut, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountOut:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// IndexPoolMint event

type IndexPoolMintEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	TokenIn   eth.Address `eth:""`
	AmountIn  *big.Int    `eth:""`
	Recipient eth.Address `eth:",indexed"`
}

var hashIndexPoolMintEvent = eth.Keccak256([]byte("Mint(address,address,uint256,address)"))

func IsIndexPoolMintEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashIndexPoolMintEvent)
}

func NewIndexPoolMintEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*IndexPoolMintEvent, error) {
	var err error
	ev := &IndexPoolMintEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.TokenIn, err = dec.DataDecoder.ReadAddress()
	if err != nil {
		return nil, fmt.Errorf("reading tokenIn:  %w", err)
	}
	ev.AmountIn, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountIn:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f3.(eth.Address)
	return ev, nil
}

// IndexPoolSwap event

type IndexPoolSwapEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Recipient eth.Address `eth:",indexed"`
	TokenIn   eth.Address `eth:",indexed"`
	TokenOut  eth.Address `eth:",indexed"`
	AmountIn  *big.Int    `eth:""`
	AmountOut *big.Int    `eth:""`
}

var hashIndexPoolSwapEvent = eth.Keccak256([]byte("Swap(address,address,address,uint256,uint256)"))

func IsIndexPoolSwapEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashIndexPoolSwapEvent)
}

func NewIndexPoolSwapEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*IndexPoolSwapEvent, error) {
	var err error
	ev := &IndexPoolSwapEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenIn: %w", err)
	}
	ev.TokenIn = f1.(eth.Address)
	f2, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading tokenOut: %w", err)
	}
	ev.TokenOut = f2.(eth.Address)
	ev.AmountIn, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountIn:  %w", err)
	}
	ev.AmountOut, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amountOut:  %w", err)
	}
	return ev, nil
}

// IndexPoolTransfer event

type IndexPoolTransferEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Recipient eth.Address `eth:",indexed"`
	Amount    *big.Int    `eth:""`
}

var hashIndexPoolTransferEvent = eth.Keccak256([]byte("Transfer(address,address,uint256)"))

func IsIndexPoolTransferEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashIndexPoolTransferEvent)
}

func NewIndexPoolTransferEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*IndexPoolTransferEvent, error) {
	var err error
	ev := &IndexPoolTransferEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f1.(eth.Address)
	ev.Amount, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount:  %w", err)
	}
	return ev, nil
}

// MasterDeployer
// MasterDeployerAddToWhitelist event

type MasterDeployerAddToWhitelistEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Factory eth.Address `eth:",indexed"`
}

var hashMasterDeployerAddToWhitelistEvent = eth.Keccak256([]byte("AddToWhitelist(address)"))

func IsMasterDeployerAddToWhitelistEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerAddToWhitelistEvent)
}

func NewMasterDeployerAddToWhitelistEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerAddToWhitelistEvent, error) {
	var err error
	ev := &MasterDeployerAddToWhitelistEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading _factory: %w", err)
	}
	ev.Factory = f0.(eth.Address)
	return ev, nil
}

// MasterDeployerBarFeeUpdated event

type MasterDeployerBarFeeUpdatedEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	BarFee *big.Int `eth:",indexed"`
}

var hashMasterDeployerBarFeeUpdatedEvent = eth.Keccak256([]byte("BarFeeUpdated(uint256)"))

func IsMasterDeployerBarFeeUpdatedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerBarFeeUpdatedEvent)
}

func NewMasterDeployerBarFeeUpdatedEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerBarFeeUpdatedEvent, error) {
	var err error
	ev := &MasterDeployerBarFeeUpdatedEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("uint256")
	if err != nil {
		return nil, fmt.Errorf("reading _barFee: %w", err)
	}
	ev.BarFee = f0.(*big.Int)
	return ev, nil
}

// MasterDeployerDeployPool event

type MasterDeployerDeployPoolEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Factory eth.Address `eth:",indexed"`
	Pool    eth.Address `eth:",indexed"`
}

var hashMasterDeployerDeployPoolEvent = eth.Keccak256([]byte("DeployPool(address,address)"))

func IsMasterDeployerDeployPoolEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerDeployPoolEvent)
}

func NewMasterDeployerDeployPoolEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerDeployPoolEvent, error) {
	var err error
	ev := &MasterDeployerDeployPoolEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading _factory: %w", err)
	}
	ev.Factory = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading pool: %w", err)
	}
	ev.Pool = f1.(eth.Address)
	return ev, nil
}

// MasterDeployerMigratorUpdated event

type MasterDeployerMigratorUpdatedEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Migrator eth.Address `eth:",indexed"`
}

var hashMasterDeployerMigratorUpdatedEvent = eth.Keccak256([]byte("MigratorUpdated(address)"))

func IsMasterDeployerMigratorUpdatedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerMigratorUpdatedEvent)
}

func NewMasterDeployerMigratorUpdatedEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerMigratorUpdatedEvent, error) {
	var err error
	ev := &MasterDeployerMigratorUpdatedEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading _migrator: %w", err)
	}
	ev.Migrator = f0.(eth.Address)
	return ev, nil
}

// MasterDeployerRemoveFromWhitelist event

type MasterDeployerRemoveFromWhitelistEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Factory eth.Address `eth:",indexed"`
}

var hashMasterDeployerRemoveFromWhitelistEvent = eth.Keccak256([]byte("RemoveFromWhitelist(address)"))

func IsMasterDeployerRemoveFromWhitelistEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerRemoveFromWhitelistEvent)
}

func NewMasterDeployerRemoveFromWhitelistEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerRemoveFromWhitelistEvent, error) {
	var err error
	ev := &MasterDeployerRemoveFromWhitelistEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading _factory: %w", err)
	}
	ev.Factory = f0.(eth.Address)
	return ev, nil
}

// MasterDeployerTransferOwner event

type MasterDeployerTransferOwnerEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Recipient eth.Address `eth:",indexed"`
}

var hashMasterDeployerTransferOwnerEvent = eth.Keccak256([]byte("TransferOwner(address,address)"))

func IsMasterDeployerTransferOwnerEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerTransferOwnerEvent)
}

func NewMasterDeployerTransferOwnerEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerTransferOwnerEvent, error) {
	var err error
	ev := &MasterDeployerTransferOwnerEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f1.(eth.Address)
	return ev, nil
}

// MasterDeployerTransferOwnerClaim event

type MasterDeployerTransferOwnerClaimEvent struct {
	*entity.BaseEvent
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender    eth.Address `eth:",indexed"`
	Recipient eth.Address `eth:",indexed"`
}

var hashMasterDeployerTransferOwnerClaimEvent = eth.Keccak256([]byte("TransferOwnerClaim(address,address)"))

func IsMasterDeployerTransferOwnerClaimEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashMasterDeployerTransferOwnerClaimEvent)
}

func NewMasterDeployerTransferOwnerClaimEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*MasterDeployerTransferOwnerClaimEvent, error) {
	var err error
	ev := &MasterDeployerTransferOwnerClaimEvent{
		BaseEvent:  &entity.BaseEvent{},
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	ev.SetBlockAndTransaction(block, trace)

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading recipient: %w", err)
	}
	ev.Recipient = f1.(eth.Address)
	return ev, nil
}

func DecodeEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (interface{}, error) {

	if IsConcentratedLiquidityPoolBurnEvent(log) {
		ev, err := NewConcentratedLiquidityPoolBurnEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConcentratedLiquidityPoolBurn event: %w", err)
		}
		return ev, nil
	}
	if IsConcentratedLiquidityPoolCollectEvent(log) {
		ev, err := NewConcentratedLiquidityPoolCollectEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConcentratedLiquidityPoolCollect event: %w", err)
		}
		return ev, nil
	}
	if IsConcentratedLiquidityPoolMintEvent(log) {
		ev, err := NewConcentratedLiquidityPoolMintEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConcentratedLiquidityPoolMint event: %w", err)
		}
		return ev, nil
	}
	if IsConcentratedLiquidityPoolSwapEvent(log) {
		ev, err := NewConcentratedLiquidityPoolSwapEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConcentratedLiquidityPoolSwap event: %w", err)
		}
		return ev, nil
	}
	if IsConcentratedLiquidityPoolSyncEvent(log) {
		ev, err := NewConcentratedLiquidityPoolSyncEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConcentratedLiquidityPoolSync event: %w", err)
		}
		return ev, nil
	}

	if IsConstantProductPoolApprovalEvent(log) {
		ev, err := NewConstantProductPoolApprovalEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConstantProductPoolApproval event: %w", err)
		}
		return ev, nil
	}
	if IsConstantProductPoolBurnEvent(log) {
		ev, err := NewConstantProductPoolBurnEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConstantProductPoolBurn event: %w", err)
		}
		return ev, nil
	}
	if IsConstantProductPoolMintEvent(log) {
		ev, err := NewConstantProductPoolMintEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConstantProductPoolMint event: %w", err)
		}
		return ev, nil
	}
	if IsConstantProductPoolSwapEvent(log) {
		ev, err := NewConstantProductPoolSwapEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConstantProductPoolSwap event: %w", err)
		}
		return ev, nil
	}
	if IsConstantProductPoolSyncEvent(log) {
		ev, err := NewConstantProductPoolSyncEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConstantProductPoolSync event: %w", err)
		}
		return ev, nil
	}
	if IsConstantProductPoolTransferEvent(log) {
		ev, err := NewConstantProductPoolTransferEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding ConstantProductPoolTransfer event: %w", err)
		}
		return ev, nil
	}

	if IsHybridPoolApprovalEvent(log) {
		ev, err := NewHybridPoolApprovalEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding HybridPoolApproval event: %w", err)
		}
		return ev, nil
	}
	if IsHybridPoolBurnEvent(log) {
		ev, err := NewHybridPoolBurnEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding HybridPoolBurn event: %w", err)
		}
		return ev, nil
	}
	if IsHybridPoolMintEvent(log) {
		ev, err := NewHybridPoolMintEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding HybridPoolMint event: %w", err)
		}
		return ev, nil
	}
	if IsHybridPoolSwapEvent(log) {
		ev, err := NewHybridPoolSwapEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding HybridPoolSwap event: %w", err)
		}
		return ev, nil
	}
	if IsHybridPoolSyncEvent(log) {
		ev, err := NewHybridPoolSyncEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding HybridPoolSync event: %w", err)
		}
		return ev, nil
	}
	if IsHybridPoolTransferEvent(log) {
		ev, err := NewHybridPoolTransferEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding HybridPoolTransfer event: %w", err)
		}
		return ev, nil
	}

	if IsIndexPoolApprovalEvent(log) {
		ev, err := NewIndexPoolApprovalEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding IndexPoolApproval event: %w", err)
		}
		return ev, nil
	}
	if IsIndexPoolBurnEvent(log) {
		ev, err := NewIndexPoolBurnEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding IndexPoolBurn event: %w", err)
		}
		return ev, nil
	}
	if IsIndexPoolMintEvent(log) {
		ev, err := NewIndexPoolMintEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding IndexPoolMint event: %w", err)
		}
		return ev, nil
	}
	if IsIndexPoolSwapEvent(log) {
		ev, err := NewIndexPoolSwapEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding IndexPoolSwap event: %w", err)
		}
		return ev, nil
	}
	if IsIndexPoolTransferEvent(log) {
		ev, err := NewIndexPoolTransferEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding IndexPoolTransfer event: %w", err)
		}
		return ev, nil
	}

	if IsMasterDeployerAddToWhitelistEvent(log) {
		ev, err := NewMasterDeployerAddToWhitelistEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerAddToWhitelist event: %w", err)
		}
		return ev, nil
	}
	if IsMasterDeployerBarFeeUpdatedEvent(log) {
		ev, err := NewMasterDeployerBarFeeUpdatedEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerBarFeeUpdated event: %w", err)
		}
		return ev, nil
	}
	if IsMasterDeployerDeployPoolEvent(log) {
		ev, err := NewMasterDeployerDeployPoolEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerDeployPool event: %w", err)
		}
		return ev, nil
	}
	if IsMasterDeployerMigratorUpdatedEvent(log) {
		ev, err := NewMasterDeployerMigratorUpdatedEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerMigratorUpdated event: %w", err)
		}
		return ev, nil
	}
	if IsMasterDeployerRemoveFromWhitelistEvent(log) {
		ev, err := NewMasterDeployerRemoveFromWhitelistEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerRemoveFromWhitelist event: %w", err)
		}
		return ev, nil
	}
	if IsMasterDeployerTransferOwnerEvent(log) {
		ev, err := NewMasterDeployerTransferOwnerEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerTransferOwner event: %w", err)
		}
		return ev, nil
	}
	if IsMasterDeployerTransferOwnerClaimEvent(log) {
		ev, err := NewMasterDeployerTransferOwnerClaimEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding MasterDeployerTransferOwnerClaim event: %w", err)
		}
		return ev, nil
	}

	return nil, nil
}

type DynamicDataSourceXXX struct {
	entity.Base

	Context string `db:"context" csv:"context"`
	ABI     string `db:"abi" csv:"abi"`
}

func NewDynamicDataSource(id string, abi string, context string) *DynamicDataSourceXXX {
	return &DynamicDataSourceXXX{
		Base:    entity.NewBase(id),
		Context: context,
		ABI:     abi,
	}
}
func (s *Subgraph) CreateConstantProductPoolTemplate(address eth.Address, obj interface{}) error {
	cnt, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	ds := NewDynamicDataSource(address.Pretty(), "ConstantProductPool", string(cnt))

	if err := s.Save(ds); err != nil {
		return fmt.Errorf("saving ConstantProductPool datasource: %w", err)
	}

	s.CurrentBlockDynamicDataSources[address.Pretty()] = ds

	return nil
}
func (s *Subgraph) CreateConcentratedLiquidityPoolTemplate(address eth.Address, obj interface{}) error {
	cnt, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	ds := NewDynamicDataSource(address.Pretty(), "ConcentratedLiquidityPool", string(cnt))

	if err := s.Save(ds); err != nil {
		return fmt.Errorf("saving ConcentratedLiquidityPool datasource: %w", err)
	}

	s.CurrentBlockDynamicDataSources[address.Pretty()] = ds

	return nil
}
func (s *Subgraph) CreateHybridPoolTemplate(address eth.Address, obj interface{}) error {
	cnt, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	ds := NewDynamicDataSource(address.Pretty(), "HybridPool", string(cnt))

	if err := s.Save(ds); err != nil {
		return fmt.Errorf("saving HybridPool datasource: %w", err)
	}

	s.CurrentBlockDynamicDataSources[address.Pretty()] = ds

	return nil
}
func (s *Subgraph) CreateIndexPoolTemplate(address eth.Address, obj interface{}) error {
	cnt, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	ds := NewDynamicDataSource(address.Pretty(), "IndexPool", string(cnt))

	if err := s.Save(ds); err != nil {
		return fmt.Errorf("saving IndexPool datasource: %w", err)
	}

	s.CurrentBlockDynamicDataSources[address.Pretty()] = ds

	return nil
}

func (s *Subgraph) IsDynamicDataSource(address string) bool {
	_, ok := s.DynamicDataSources[address]
	return ok
}

func (s *Subgraph) IsCurrentDynamicDataSource(address string) bool {
	_, ok := s.CurrentBlockDynamicDataSources[address]
	return ok
}

func (s *Subgraph) LoadDynamicDataSources(blockNum uint64) error {
	res, err := s.LoadAllDistinct(&DynamicDataSourceXXX{}, blockNum)
	if err != nil {
		return fmt.Errorf("loading dynamic data sources: %w", err)
	}
	for _, dsi := range res {
		ds := dsi.(*DynamicDataSourceXXX)
		if ds.ABI == "ConstantProductPool" {
			s.DynamicDataSources[ds.GetID()] = ds
		}
	}
	for _, dsi := range res {
		ds := dsi.(*DynamicDataSourceXXX)
		if ds.ABI == "ConcentratedLiquidityPool" {
			s.DynamicDataSources[ds.GetID()] = ds
		}
	}
	for _, dsi := range res {
		ds := dsi.(*DynamicDataSourceXXX)
		if ds.ABI == "HybridPool" {
			s.DynamicDataSources[ds.GetID()] = ds
		}
	}
	for _, dsi := range res {
		ds := dsi.(*DynamicDataSourceXXX)
		if ds.ABI == "IndexPool" {
			s.DynamicDataSources[ds.GetID()] = ds
		}
	}
	return nil
}

type DDL struct {
	createTables map[string]string
	indexes      map[string][]*index
	schemaSetup  string
}

var ddl *DDL

type index struct {
	createStatement string
	dropStatement   string
}

var createTables = map[string]string{}
var indexes = map[string][]*index{}

func init() {
	ddl = &DDL{
		createTables: map[string]string{},
		indexes:      map[string][]*index{},
	}

	Definition.DDL = ddl

	ddl.createTables["price"] = `
create table if not exists %%SCHEMA%%.price
(
	id text not null,

	"price_usd" numeric not null,

	vid bigserial not null constraint price_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.price owner to graph;
alter sequence %%SCHEMA%%.price_vid_seq owned by %%SCHEMA%%.price.vid;
alter table only %%SCHEMA%%.price alter column vid SET DEFAULT nextval('%%SCHEMA%%.price_vid_seq'::regclass);
`

	ddl.createTables["master_deployer"] = `
create table if not exists %%SCHEMA%%.master_deployer
(
	id text not null,

	"pending_owner" bytea not null,

	"previous_owner" bytea not null,

	"owner" bytea not null,

	"migrator" bytea not null,

	"bar_fee" numeric not null,

	"bar_fee_to" bytea not null,

	"bento" bytea not null,

	"factory_count" numeric not null,

	"pool_count" numeric not null,

	vid bigserial not null constraint master_deployer_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.master_deployer owner to graph;
alter sequence %%SCHEMA%%.master_deployer_vid_seq owned by %%SCHEMA%%.master_deployer.vid;
alter table only %%SCHEMA%%.master_deployer alter column vid SET DEFAULT nextval('%%SCHEMA%%.master_deployer_vid_seq'::regclass);
`

	ddl.createTables["whitelisted_factory"] = `
create table if not exists %%SCHEMA%%.whitelisted_factory
(
	id text not null,

	"master_deployer" text not null,

	vid bigserial not null constraint whitelisted_factory_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.whitelisted_factory owner to graph;
alter sequence %%SCHEMA%%.whitelisted_factory_vid_seq owned by %%SCHEMA%%.whitelisted_factory.vid;
alter table only %%SCHEMA%%.whitelisted_factory alter column vid SET DEFAULT nextval('%%SCHEMA%%.whitelisted_factory_vid_seq'::regclass);
`

	ddl.createTables["constant_product_pool_factory"] = `
create table if not exists %%SCHEMA%%.constant_product_pool_factory
(
	id text not null,

	"master_deployer" text not null,

	"pool_count" numeric not null,

	"transaction_count" numeric not null,

	vid bigserial not null constraint constant_product_pool_factory_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.constant_product_pool_factory owner to graph;
alter sequence %%SCHEMA%%.constant_product_pool_factory_vid_seq owned by %%SCHEMA%%.constant_product_pool_factory.vid;
alter table only %%SCHEMA%%.constant_product_pool_factory alter column vid SET DEFAULT nextval('%%SCHEMA%%.constant_product_pool_factory_vid_seq'::regclass);
`

	ddl.createTables["constant_product_pool"] = `
create table if not exists %%SCHEMA%%.constant_product_pool
(
	id text not null,

	"master_deployer" text not null,

	"factory" text not null,

	"token_0" text not null,

	"token_1" text not null,

	"reserve_0" numeric not null,

	"reserve_1" numeric not null,

	"total_supply" numeric not null,

	"transaction_count" numeric not null,

	"total_value_locked" numeric not null,

	"volume" numeric not null,

	vid bigserial not null constraint constant_product_pool_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.constant_product_pool owner to graph;
alter sequence %%SCHEMA%%.constant_product_pool_vid_seq owned by %%SCHEMA%%.constant_product_pool.vid;
alter table only %%SCHEMA%%.constant_product_pool alter column vid SET DEFAULT nextval('%%SCHEMA%%.constant_product_pool_vid_seq'::regclass);
`

	ddl.createTables["concentrated_liquidity_pool_factory"] = `
create table if not exists %%SCHEMA%%.concentrated_liquidity_pool_factory
(
	id text not null,

	"master_deployer" text not null,

	"pool_count" numeric not null,

	"transaction_count" numeric not null,

	vid bigserial not null constraint concentrated_liquidity_pool_factory_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.concentrated_liquidity_pool_factory owner to graph;
alter sequence %%SCHEMA%%.concentrated_liquidity_pool_factory_vid_seq owned by %%SCHEMA%%.concentrated_liquidity_pool_factory.vid;
alter table only %%SCHEMA%%.concentrated_liquidity_pool_factory alter column vid SET DEFAULT nextval('%%SCHEMA%%.concentrated_liquidity_pool_factory_vid_seq'::regclass);
`

	ddl.createTables["concentrated_liquidity_pool"] = `
create table if not exists %%SCHEMA%%.concentrated_liquidity_pool
(
	id text not null,

	"master_deployer" text not null,

	"factory" text not null,

	"token_0" text not null,

	"token_1" text not null,

	"reserve_0" numeric not null,

	"reserve_1" numeric not null,

	"total_supply" numeric not null,

	"transaction_count" numeric not null,

	"total_value_locked" numeric not null,

	"volume" numeric not null,

	vid bigserial not null constraint concentrated_liquidity_pool_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.concentrated_liquidity_pool owner to graph;
alter sequence %%SCHEMA%%.concentrated_liquidity_pool_vid_seq owned by %%SCHEMA%%.concentrated_liquidity_pool.vid;
alter table only %%SCHEMA%%.concentrated_liquidity_pool alter column vid SET DEFAULT nextval('%%SCHEMA%%.concentrated_liquidity_pool_vid_seq'::regclass);
`

	ddl.createTables["hybrid_pool_factory"] = `
create table if not exists %%SCHEMA%%.hybrid_pool_factory
(
	id text not null,

	"master_deployer" text not null,

	"pool_count" numeric not null,

	"transaction_count" numeric not null,

	vid bigserial not null constraint hybrid_pool_factory_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.hybrid_pool_factory owner to graph;
alter sequence %%SCHEMA%%.hybrid_pool_factory_vid_seq owned by %%SCHEMA%%.hybrid_pool_factory.vid;
alter table only %%SCHEMA%%.hybrid_pool_factory alter column vid SET DEFAULT nextval('%%SCHEMA%%.hybrid_pool_factory_vid_seq'::regclass);
`

	ddl.createTables["hybrid_pool"] = `
create table if not exists %%SCHEMA%%.hybrid_pool
(
	id text not null,

	"master_deployer" text not null,

	"factory" text not null,

	"token_0" text not null,

	"token_1" text not null,

	"token_0_precision_multiplier" numeric not null,

	"token_1_precision_multiplier" numeric not null,

	"reserve_0" numeric not null,

	"reserve_1" numeric not null,

	"total_supply" numeric not null,

	"transaction_count" numeric not null,

	"total_value_locked" numeric not null,

	"volume" numeric not null,

	vid bigserial not null constraint hybrid_pool_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.hybrid_pool owner to graph;
alter sequence %%SCHEMA%%.hybrid_pool_vid_seq owned by %%SCHEMA%%.hybrid_pool.vid;
alter table only %%SCHEMA%%.hybrid_pool alter column vid SET DEFAULT nextval('%%SCHEMA%%.hybrid_pool_vid_seq'::regclass);
`

	ddl.createTables["index_pool_factory"] = `
create table if not exists %%SCHEMA%%.index_pool_factory
(
	id text not null,

	"master_deployer" text not null,

	"pool_count" numeric not null,

	"transaction_count" numeric not null,

	vid bigserial not null constraint index_pool_factory_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.index_pool_factory owner to graph;
alter sequence %%SCHEMA%%.index_pool_factory_vid_seq owned by %%SCHEMA%%.index_pool_factory.vid;
alter table only %%SCHEMA%%.index_pool_factory alter column vid SET DEFAULT nextval('%%SCHEMA%%.index_pool_factory_vid_seq'::regclass);
`

	ddl.createTables["index_pool"] = `
create table if not exists %%SCHEMA%%.index_pool
(
	id text not null,

	"master_deployer" text not null,

	"factory" text not null,

	"token_0" text not null,

	"token_1" text not null,

	"reserve_0" numeric not null,

	"reserve_1" numeric not null,

	"total_supply" numeric not null,

	"transaction_count" numeric not null,

	"total_value_locked" numeric not null,

	"volume" numeric not null,

	vid bigserial not null constraint index_pool_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.index_pool owner to graph;
alter sequence %%SCHEMA%%.index_pool_vid_seq owned by %%SCHEMA%%.index_pool.vid;
alter table only %%SCHEMA%%.index_pool alter column vid SET DEFAULT nextval('%%SCHEMA%%.index_pool_vid_seq'::regclass);
`

	ddl.createTables["token"] = `
create table if not exists %%SCHEMA%%.token
(
	id text not null,

	"symbol" text not null,

	"symbol_success" boolean not null,

	"name" text not null,

	"name_success" boolean not null,

	"decimals" numeric not null,

	"decimals_success" boolean not null,

	"transaction_count" numeric not null,

	"total_value_locked" numeric not null,

	vid bigserial not null constraint token_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.token owner to graph;
alter sequence %%SCHEMA%%.token_vid_seq owned by %%SCHEMA%%.token.vid;
alter table only %%SCHEMA%%.token alter column vid SET DEFAULT nextval('%%SCHEMA%%.token_vid_seq'::regclass);
`

	ddl.createTables["mint"] = `
create table if not exists %%SCHEMA%%.mint
(
	id text not null,

	"pool" text not null,

	"transaction" text not null,

	"token_0" text not null,

	"token_1" text not null,

	"amount" numeric not null,

	"amount_0" numeric not null,

	"amount_1" numeric not null,

	"sender" bytea not null,

	"recipient" bytea not null,

	"log_index" numeric not null,

	vid bigserial not null constraint mint_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.mint owner to graph;
alter sequence %%SCHEMA%%.mint_vid_seq owned by %%SCHEMA%%.mint.vid;
alter table only %%SCHEMA%%.mint alter column vid SET DEFAULT nextval('%%SCHEMA%%.mint_vid_seq'::regclass);
`

	ddl.createTables["burn"] = `
create table if not exists %%SCHEMA%%.burn
(
	id text not null,

	"pool" text not null,

	"transaction" text not null,

	"token_0" text not null,

	"token_1" text not null,

	"amount" numeric not null,

	"amount_0" numeric not null,

	"amount_1" numeric not null,

	"sender" bytea not null,

	"recipient" bytea not null,

	"log_index" numeric not null,

	vid bigserial not null constraint burn_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.burn owner to graph;
alter sequence %%SCHEMA%%.burn_vid_seq owned by %%SCHEMA%%.burn.vid;
alter table only %%SCHEMA%%.burn alter column vid SET DEFAULT nextval('%%SCHEMA%%.burn_vid_seq'::regclass);
`

	ddl.createTables["swap"] = `
create table if not exists %%SCHEMA%%.swap
(
	id text not null,

	"pool" text not null,

	"transaction" text not null,

	"token_in" text not null,

	"token_out" text not null,

	"amount_in" numeric not null,

	"amount_out" numeric not null,

	"recipient" bytea not null,

	"log_index" numeric not null,

	vid bigserial not null constraint swap_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.swap owner to graph;
alter sequence %%SCHEMA%%.swap_vid_seq owned by %%SCHEMA%%.swap.vid;
alter table only %%SCHEMA%%.swap alter column vid SET DEFAULT nextval('%%SCHEMA%%.swap_vid_seq'::regclass);
`

	ddl.createTables["transaction"] = `
create table if not exists %%SCHEMA%%.transaction
(
	id text not null,

	"gas_used" numeric not null,

	"gas_limit" numeric not null,

	"gas_price" numeric not null,

	"block" numeric not null,

	"timestamp" numeric not null,

	vid bigserial not null constraint transaction_pkey primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.transaction owner to graph;
alter sequence %%SCHEMA%%.transaction_vid_seq owned by %%SCHEMA%%.transaction.vid;
alter table only %%SCHEMA%%.transaction alter column vid SET DEFAULT nextval('%%SCHEMA%%.transaction_vid_seq'::regclass);
`

	ddl.indexes["price"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists price_block_range_closed on %%SCHEMA%%.price (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.price_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists price_id on %%SCHEMA%%.price (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.price_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists price_updated_block_number on %%SCHEMA%%.price (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.price_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists price_id_block_range_fake_excl on %%SCHEMA%%.price using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.price_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists price_price_usd on %%SCHEMA%%.price using btree ("price_usd");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.price_price_usd;`,
		})

		return indexes
	}()

	ddl.indexes["master_deployer"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_block_range_closed on %%SCHEMA%%.master_deployer (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_id on %%SCHEMA%%.master_deployer (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_updated_block_number on %%SCHEMA%%.master_deployer (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_id_block_range_fake_excl on %%SCHEMA%%.master_deployer using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_pending_owner on %%SCHEMA%%.master_deployer using btree ("pending_owner");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_pending_owner;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_previous_owner on %%SCHEMA%%.master_deployer using btree ("previous_owner");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_previous_owner;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_owner on %%SCHEMA%%.master_deployer using btree ("owner");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_owner;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_migrator on %%SCHEMA%%.master_deployer using btree ("migrator");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_migrator;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_bar_fee on %%SCHEMA%%.master_deployer using btree ("bar_fee");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_bar_fee;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_bar_fee_to on %%SCHEMA%%.master_deployer using btree ("bar_fee_to");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_bar_fee_to;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_bento on %%SCHEMA%%.master_deployer using btree ("bento");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_bento;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_factory_count on %%SCHEMA%%.master_deployer using btree ("factory_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_factory_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists master_deployer_pool_count on %%SCHEMA%%.master_deployer using btree ("pool_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.master_deployer_pool_count;`,
		})

		return indexes
	}()

	ddl.indexes["whitelisted_factory"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists whitelisted_factory_block_range_closed on %%SCHEMA%%.whitelisted_factory (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.whitelisted_factory_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists whitelisted_factory_id on %%SCHEMA%%.whitelisted_factory (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.whitelisted_factory_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists whitelisted_factory_updated_block_number on %%SCHEMA%%.whitelisted_factory (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.whitelisted_factory_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists whitelisted_factory_id_block_range_fake_excl on %%SCHEMA%%.whitelisted_factory using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.whitelisted_factory_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists whitelisted_factory_master_deployer on %%SCHEMA%%.whitelisted_factory using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.whitelisted_factory_master_deployer;`,
		})

		return indexes
	}()

	ddl.indexes["constant_product_pool_factory"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_block_range_closed on %%SCHEMA%%.constant_product_pool_factory (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_id on %%SCHEMA%%.constant_product_pool_factory (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_updated_block_number on %%SCHEMA%%.constant_product_pool_factory (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_id_block_range_fake_excl on %%SCHEMA%%.constant_product_pool_factory using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_master_deployer on %%SCHEMA%%.constant_product_pool_factory using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_pool_count on %%SCHEMA%%.constant_product_pool_factory using btree ("pool_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_pool_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory_transaction_count on %%SCHEMA%%.constant_product_pool_factory using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory_transaction_count;`,
		})

		return indexes
	}()

	ddl.indexes["constant_product_pool"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_block_range_closed on %%SCHEMA%%.constant_product_pool (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_id on %%SCHEMA%%.constant_product_pool (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_updated_block_number on %%SCHEMA%%.constant_product_pool (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_id_block_range_fake_excl on %%SCHEMA%%.constant_product_pool using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_master_deployer on %%SCHEMA%%.constant_product_pool using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_factory on %%SCHEMA%%.constant_product_pool using gist ("factory", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_factory;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_token_0 on %%SCHEMA%%.constant_product_pool using gist ("token_0", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_token_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_token_1 on %%SCHEMA%%.constant_product_pool using gist ("token_1", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_token_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_reserve_0 on %%SCHEMA%%.constant_product_pool using btree ("reserve_0");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_reserve_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_reserve_1 on %%SCHEMA%%.constant_product_pool using btree ("reserve_1");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_reserve_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_total_supply on %%SCHEMA%%.constant_product_pool using btree ("total_supply");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_total_supply;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_transaction_count on %%SCHEMA%%.constant_product_pool using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_transaction_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_total_value_locked on %%SCHEMA%%.constant_product_pool using btree ("total_value_locked");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_total_value_locked;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists constant_product_pool_volume on %%SCHEMA%%.constant_product_pool using btree ("volume");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.constant_product_pool_volume;`,
		})

		return indexes
	}()

	ddl.indexes["concentrated_liquidity_pool_factory"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_block_range_closed on %%SCHEMA%%.concentrated_liquidity_pool_factory (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_id on %%SCHEMA%%.concentrated_liquidity_pool_factory (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_updated_block_number on %%SCHEMA%%.concentrated_liquidity_pool_factory (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_id_block_range_fake_excl on %%SCHEMA%%.concentrated_liquidity_pool_factory using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_master_deployer on %%SCHEMA%%.concentrated_liquidity_pool_factory using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_pool_count on %%SCHEMA%%.concentrated_liquidity_pool_factory using btree ("pool_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_pool_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory_transaction_count on %%SCHEMA%%.concentrated_liquidity_pool_factory using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory_transaction_count;`,
		})

		return indexes
	}()

	ddl.indexes["concentrated_liquidity_pool"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_block_range_closed on %%SCHEMA%%.concentrated_liquidity_pool (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_id on %%SCHEMA%%.concentrated_liquidity_pool (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_updated_block_number on %%SCHEMA%%.concentrated_liquidity_pool (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_id_block_range_fake_excl on %%SCHEMA%%.concentrated_liquidity_pool using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_master_deployer on %%SCHEMA%%.concentrated_liquidity_pool using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_factory on %%SCHEMA%%.concentrated_liquidity_pool using gist ("factory", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_factory;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_token_0 on %%SCHEMA%%.concentrated_liquidity_pool using gist ("token_0", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_token_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_token_1 on %%SCHEMA%%.concentrated_liquidity_pool using gist ("token_1", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_token_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_reserve_0 on %%SCHEMA%%.concentrated_liquidity_pool using btree ("reserve_0");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_reserve_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_reserve_1 on %%SCHEMA%%.concentrated_liquidity_pool using btree ("reserve_1");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_reserve_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_total_supply on %%SCHEMA%%.concentrated_liquidity_pool using btree ("total_supply");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_total_supply;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_transaction_count on %%SCHEMA%%.concentrated_liquidity_pool using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_transaction_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_total_value_locked on %%SCHEMA%%.concentrated_liquidity_pool using btree ("total_value_locked");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_total_value_locked;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists concentrated_liquidity_pool_volume on %%SCHEMA%%.concentrated_liquidity_pool using btree ("volume");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.concentrated_liquidity_pool_volume;`,
		})

		return indexes
	}()

	ddl.indexes["hybrid_pool_factory"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_block_range_closed on %%SCHEMA%%.hybrid_pool_factory (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_id on %%SCHEMA%%.hybrid_pool_factory (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_updated_block_number on %%SCHEMA%%.hybrid_pool_factory (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_id_block_range_fake_excl on %%SCHEMA%%.hybrid_pool_factory using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_master_deployer on %%SCHEMA%%.hybrid_pool_factory using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_pool_count on %%SCHEMA%%.hybrid_pool_factory using btree ("pool_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_pool_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory_transaction_count on %%SCHEMA%%.hybrid_pool_factory using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory_transaction_count;`,
		})

		return indexes
	}()

	ddl.indexes["hybrid_pool"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_block_range_closed on %%SCHEMA%%.hybrid_pool (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_id on %%SCHEMA%%.hybrid_pool (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_updated_block_number on %%SCHEMA%%.hybrid_pool (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_id_block_range_fake_excl on %%SCHEMA%%.hybrid_pool using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_master_deployer on %%SCHEMA%%.hybrid_pool using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_factory on %%SCHEMA%%.hybrid_pool using gist ("factory", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_factory;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_token_0 on %%SCHEMA%%.hybrid_pool using gist ("token_0", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_token_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_token_1 on %%SCHEMA%%.hybrid_pool using gist ("token_1", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_token_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_token_0_precision_multiplier on %%SCHEMA%%.hybrid_pool using btree ("token_0_precision_multiplier");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_token_0_precision_multiplier;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_token_1_precision_multiplier on %%SCHEMA%%.hybrid_pool using btree ("token_1_precision_multiplier");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_token_1_precision_multiplier;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_reserve_0 on %%SCHEMA%%.hybrid_pool using btree ("reserve_0");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_reserve_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_reserve_1 on %%SCHEMA%%.hybrid_pool using btree ("reserve_1");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_reserve_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_total_supply on %%SCHEMA%%.hybrid_pool using btree ("total_supply");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_total_supply;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_transaction_count on %%SCHEMA%%.hybrid_pool using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_transaction_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_total_value_locked on %%SCHEMA%%.hybrid_pool using btree ("total_value_locked");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_total_value_locked;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists hybrid_pool_volume on %%SCHEMA%%.hybrid_pool using btree ("volume");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.hybrid_pool_volume;`,
		})

		return indexes
	}()

	ddl.indexes["index_pool_factory"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_block_range_closed on %%SCHEMA%%.index_pool_factory (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_id on %%SCHEMA%%.index_pool_factory (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_updated_block_number on %%SCHEMA%%.index_pool_factory (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_id_block_range_fake_excl on %%SCHEMA%%.index_pool_factory using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_master_deployer on %%SCHEMA%%.index_pool_factory using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_pool_count on %%SCHEMA%%.index_pool_factory using btree ("pool_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_pool_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory_transaction_count on %%SCHEMA%%.index_pool_factory using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory_transaction_count;`,
		})

		return indexes
	}()

	ddl.indexes["index_pool"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_block_range_closed on %%SCHEMA%%.index_pool (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_id on %%SCHEMA%%.index_pool (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_updated_block_number on %%SCHEMA%%.index_pool (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_id_block_range_fake_excl on %%SCHEMA%%.index_pool using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_master_deployer on %%SCHEMA%%.index_pool using gist ("master_deployer", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_master_deployer;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_factory on %%SCHEMA%%.index_pool using gist ("factory", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_factory;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_token_0 on %%SCHEMA%%.index_pool using gist ("token_0", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_token_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_token_1 on %%SCHEMA%%.index_pool using gist ("token_1", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_token_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_reserve_0 on %%SCHEMA%%.index_pool using btree ("reserve_0");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_reserve_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_reserve_1 on %%SCHEMA%%.index_pool using btree ("reserve_1");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_reserve_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_total_supply on %%SCHEMA%%.index_pool using btree ("total_supply");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_total_supply;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_transaction_count on %%SCHEMA%%.index_pool using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_transaction_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_total_value_locked on %%SCHEMA%%.index_pool using btree ("total_value_locked");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_total_value_locked;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists index_pool_volume on %%SCHEMA%%.index_pool using btree ("volume");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.index_pool_volume;`,
		})

		return indexes
	}()

	ddl.indexes["token"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_block_range_closed on %%SCHEMA%%.token (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_id on %%SCHEMA%%.token (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_updated_block_number on %%SCHEMA%%.token (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_id_block_range_fake_excl on %%SCHEMA%%.token using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_symbol on %%SCHEMA%%.token ("left"("symbol", 256));`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_symbol;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_symbol_success on %%SCHEMA%%.token using btree ("symbol_success");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_symbol_success;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_name on %%SCHEMA%%.token ("left"("name", 256));`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_name;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_name_success on %%SCHEMA%%.token using btree ("name_success");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_name_success;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_decimals on %%SCHEMA%%.token using btree ("decimals");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_decimals;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_decimals_success on %%SCHEMA%%.token using btree ("decimals_success");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_decimals_success;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_transaction_count on %%SCHEMA%%.token using btree ("transaction_count");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_transaction_count;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists token_total_value_locked on %%SCHEMA%%.token using btree ("total_value_locked");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.token_total_value_locked;`,
		})

		return indexes
	}()

	ddl.indexes["mint"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_block_range_closed on %%SCHEMA%%.mint (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_id on %%SCHEMA%%.mint (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_updated_block_number on %%SCHEMA%%.mint (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_id_block_range_fake_excl on %%SCHEMA%%.mint using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_pool on %%SCHEMA%%.mint using gist ("pool", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_pool;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_transaction on %%SCHEMA%%.mint using gist ("transaction", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_transaction;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_token_0 on %%SCHEMA%%.mint using gist ("token_0", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_token_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_token_1 on %%SCHEMA%%.mint using gist ("token_1", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_token_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_amount on %%SCHEMA%%.mint using btree ("amount");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_amount;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_amount_0 on %%SCHEMA%%.mint using btree ("amount_0");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_amount_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_amount_1 on %%SCHEMA%%.mint using btree ("amount_1");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_amount_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_sender on %%SCHEMA%%.mint using btree ("sender");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_sender;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_recipient on %%SCHEMA%%.mint using btree ("recipient");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_recipient;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists mint_log_index on %%SCHEMA%%.mint using btree ("log_index");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.mint_log_index;`,
		})

		return indexes
	}()

	ddl.indexes["burn"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_block_range_closed on %%SCHEMA%%.burn (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_id on %%SCHEMA%%.burn (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_updated_block_number on %%SCHEMA%%.burn (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_id_block_range_fake_excl on %%SCHEMA%%.burn using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_pool on %%SCHEMA%%.burn using gist ("pool", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_pool;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_transaction on %%SCHEMA%%.burn using gist ("transaction", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_transaction;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_token_0 on %%SCHEMA%%.burn using gist ("token_0", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_token_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_token_1 on %%SCHEMA%%.burn using gist ("token_1", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_token_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_amount on %%SCHEMA%%.burn using btree ("amount");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_amount;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_amount_0 on %%SCHEMA%%.burn using btree ("amount_0");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_amount_0;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_amount_1 on %%SCHEMA%%.burn using btree ("amount_1");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_amount_1;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_sender on %%SCHEMA%%.burn using btree ("sender");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_sender;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_recipient on %%SCHEMA%%.burn using btree ("recipient");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_recipient;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists burn_log_index on %%SCHEMA%%.burn using btree ("log_index");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.burn_log_index;`,
		})

		return indexes
	}()

	ddl.indexes["swap"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_block_range_closed on %%SCHEMA%%.swap (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_id on %%SCHEMA%%.swap (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_updated_block_number on %%SCHEMA%%.swap (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_id_block_range_fake_excl on %%SCHEMA%%.swap using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_pool on %%SCHEMA%%.swap using gist ("pool", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_pool;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_transaction on %%SCHEMA%%.swap using gist ("transaction", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_transaction;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_token_in on %%SCHEMA%%.swap using gist ("token_in", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_token_in;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_token_out on %%SCHEMA%%.swap using gist ("token_out", block_range);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_token_out;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_amount_in on %%SCHEMA%%.swap using btree ("amount_in");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_amount_in;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_amount_out on %%SCHEMA%%.swap using btree ("amount_out");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_amount_out;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_recipient on %%SCHEMA%%.swap using btree ("recipient");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_recipient;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists swap_log_index on %%SCHEMA%%.swap using btree ("log_index");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.swap_log_index;`,
		})

		return indexes
	}()

	ddl.indexes["transaction"] = func() []*index {
		var indexes []*index
		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_block_range_closed on %%SCHEMA%%.transaction (COALESCE(upper(block_range), 2147483647)) where (COALESCE(upper(block_range), 2147483647) < 2147483647);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_block_range_closed;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_id on %%SCHEMA%%.transaction (id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_id;`,
		})
		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_updated_block_number on %%SCHEMA%%.transaction (_updated_block_number);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_updated_block_number;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_id_block_range_fake_excl on %%SCHEMA%%.transaction using gist (block_range, id);`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_id_block_range_fake_excl;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_gas_used on %%SCHEMA%%.transaction using btree ("gas_used");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_gas_used;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_gas_limit on %%SCHEMA%%.transaction using btree ("gas_limit");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_gas_limit;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_gas_price on %%SCHEMA%%.transaction using btree ("gas_price");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_gas_price;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_block on %%SCHEMA%%.transaction using btree ("block");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_block;`,
		})

		indexes = append(indexes, &index{
			createStatement: `create index if not exists transaction_timestamp on %%SCHEMA%%.transaction using btree ("timestamp");`,
			dropStatement:   `drop index if exists %%SCHEMA%%.transaction_timestamp;`,
		})

		return indexes
	}()
	ddl.schemaSetup = `
CREATE SCHEMA if not exists %%SCHEMA%%;
DO
$do$
    BEGIN
        IF NOT EXISTS (
                SELECT FROM pg_catalog.pg_roles  -- SELECT list can be empty for this
                WHERE  rolname = 'graph') THEN
            CREATE ROLE graph;
        END IF;
    END
$do$;

set statement_timeout = 0;
set idle_in_transaction_session_timeout = 0;
set client_encoding = 'UTF8';
set standard_conforming_strings = on;
select pg_catalog.set_config('search_path', '', false);
set check_function_bodies = false;
set xmloption = content;
set client_min_messages = warning;
set row_security = off;

create extension if not exists btree_gist with schema %%SCHEMA%%;


create type %%SCHEMA%%.fee as enum ('DEFAULT');
alter type %%SCHEMA%%.fee owner to graph;


create type %%SCHEMA%%.pool_template as enum ('CONSTANT_PRODUCT','HYBRID','INDEX','CONCENTRATED_LIQUDITY');
alter type %%SCHEMA%%.pool_template owner to graph;


create type %%SCHEMA%%.tracking as enum ('TRACKED','UNTRACKED');
alter type %%SCHEMA%%.tracking owner to graph;


create type %%SCHEMA%%.untracked_reason as enum ('LOW_LIQUDITY','INVALID_TOKEN');
alter type %%SCHEMA%%.untracked_reason owner to graph;


create table if not exists %%SCHEMA%%.cursor
(
	id integer not null
		constraint cursor_pkey
			primary key,
	cursor text
);
alter table %%SCHEMA%%.cursor owner to graph;

create table %%SCHEMA%%.poi2$
(
    digest      bytea     not null,
    id          text      not null,
    vid         bigserial not null
        constraint poi2$_pkey
            primary key,
    block_range int4range not null,
	_updated_block_number  numeric not null,
    constraint poi2$_id_block_range_excl
        exclude using gist (id with =, block_range with &&)
);

alter table %%SCHEMA%%.poi2$
    owner to graph;

create index brin_poi2$
    on %%SCHEMA%%.poi2$ using brin (lower(block_range), COALESCE(upper(block_range), 2147483647), vid);

CREATE INDEX poi2$_updated_block_number
    ON %%SCHEMA%%.poi2$ USING btree
	(_updated_block_number ASC NULLS LAST)
	TABLESPACE pg_default;

create index poi2$_block_range_closed
    on %%SCHEMA%%.poi2$ (COALESCE(upper(block_range), 2147483647))
    where (COALESCE(upper(block_range), 2147483647) < 2147483647);

create index attr_12_0_poi2$_digest
    on %%SCHEMA%%.poi2$ (digest);

create index attr_12_1_poi2$_id
    on %%SCHEMA%%.poi2$ ("left"(id, 256));

create table if not exists %%SCHEMA%%.dynamic_data_source_xxx
(
	id text not null,
	context text not null,
	abi text not null,
	vid bigserial not null
		constraint dynamic_data_source_xxx_pkey
			primary key,
	block_range int4range not null,
	_updated_block_number numeric not null
);

alter table %%SCHEMA%%.dynamic_data_source_xxx owner to graph;

create index if not exists dynamic_data_source_xxx_block_range_closed
	on %%SCHEMA%%.dynamic_data_source_xxx (COALESCE(upper(block_range), 2147483647))
	where (COALESCE(upper(block_range), 2147483647) < 2147483647);

create index if not exists dynamic_data_source_xxx_id
	on %%SCHEMA%%.dynamic_data_source_xxx (id);

create index if not exists dynamic_data_source_xxx_abi
	on %%SCHEMA%%.dynamic_data_source_xxx (abi);

`

}

func (d *DDL) InitiateSchema(handleStatement func(statement string) error) error {
	err := handleStatement(d.schemaSetup)
	if err != nil {
		return fmt.Errorf("handle statement: %w", err)
	}
	return nil
}

func (d *DDL) CreateTables(handleStatement func(table string, statement string) error) error {
	for table, statement := range d.createTables {
		err := handleStatement(table, statement)
		if err != nil {
			return fmt.Errorf("handle statement: %w", err)
		}
	}
	return nil
}

func (d *DDL) CreateIndexes(handleStatement func(table string, statement string) error) error {
	for table, idxs := range d.indexes {
		for _, idx := range idxs {
			err := handleStatement(table, idx.createStatement)
			if err != nil {
				return fmt.Errorf("handle statement: %w", err)
			}
		}
	}
	return nil
}

func (d *DDL) DropIndexes(handleStatement func(table string, statement string) error) error {
	for table, idxs := range d.indexes {
		for _, idx := range idxs {
			err := handleStatement(table, idx.dropStatement)
			if err != nil {
				return fmt.Errorf("handle statement: %w", err)
			}
		}
	}
	return nil
}

func NewTestSubgraph(int subgraph.Intrinsics) *Subgraph {
	return &Subgraph{
		Base: subgraph.Base{
			Intrinsics: int,
			Definition: Definition,
			ID:         "testSubgraph",
			Log:        zlog,
		},
		CurrentBlockDynamicDataSources: map[string]*DynamicDataSourceXXX{},
		DynamicDataSources:             map[string]*DynamicDataSourceXXX{},
	}
}

type TestIntrinsics struct {
	store map[string]map[string]entity.Interface
	step  int
}

func NewTestIntrinsics(testCase *TestCase) *TestIntrinsics {
	i := &TestIntrinsics{
		store: make(map[string]map[string]entity.Interface),
		step:  99999,
	}

	if testCase != nil {
		i.initialize(testCase)
	}

	return i
}

func (i *TestIntrinsics) initialize(testCase *TestCase) {
	i.setStoreData(testCase.StoreData)
}

func (i *TestIntrinsics) setStoreData(ents []*TypedEntity) {
	for _, value := range ents {
		err := i.Save(value.Entity)
		if err != nil {
			panic(err)
		}
	}
}

func (i *TestIntrinsics) Save(e entity.Interface) error {
	tableName := entity.GetTableName(e)
	tbl, found := i.store[tableName]
	if !found {
		tbl = make(map[string]entity.Interface)
		i.store[tableName] = tbl
	}

	e.SetExists(true)
	e.SetMutated(i.step)

	tbl[e.GetID()] = e
	return nil
}

func (i *TestIntrinsics) Load(e entity.Interface) error {
	tableName := entity.GetTableName(e)
	tbl, found := i.store[tableName]
	if !found {
		return nil
	}

	id := e.GetID()
	cachedEntity, found := tbl[id]
	if found {
		if cachedEntity == nil {
			return nil
		}
		ve := reflect.ValueOf(e).Elem()
		ve.Set(reflect.ValueOf(cachedEntity).Elem())
		return nil
	}

	return nil
}

func (i *TestIntrinsics) LoadAllDistinct(e entity.Interface, blockNum uint64) ([]entity.Interface, error) {
	result := make([]entity.Interface, 0)

	tableName := entity.GetTableName(e)
	tbl, found := i.store[tableName]
	if !found {
		return result, nil
	}

	for _, v := range tbl {
		result = append(result, v)
	}
	return result, nil
}

func (i *TestIntrinsics) Remove(e entity.Interface) error {
	tableName := entity.GetTableName(e)
	tbl, found := i.store[tableName]
	if !found {
		return nil
	}

	id := e.GetID()
	delete(tbl, id)
	return nil
}

func (i *TestIntrinsics) Block() subgraph.BlockRef {
	return &blockRef{
		id:        "0x1",
		num:       1,
		timestamp: time.Time{},
	}
}

func (i *TestIntrinsics) Step() int {
	return i.step
}

func (i *TestIntrinsics) StepBelow(step int) bool {
	return i.step < step
}

func (i *TestIntrinsics) StepAbove(step int) bool {
	return i.step > step
}

func (i *TestIntrinsics) RPC(calls []*subgraph.RPCCall) ([]*subgraph.RPCResponse, error) {
	return nil, nil
}

type TestCase struct {
	StoreData []*TypedEntity `yaml:"storeData" json:"storeData"`
	Events    []*TypedEvent  `yaml:"events" json:"events"`
}

type TypedEntity struct {
	Type   string
	Entity entity.Interface
}

func (t *TypedEntity) UnmarshalJSON(data []byte) error {
	s := &struct {
		Type   string          `json:"type" yaml:"type"`
		Entity json.RawMessage `json:"entity" yaml:"entity"`
	}{}

	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var ent entity.Interface
	switch s.Type {
	case "price":
		tempEnt := &Price{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "master_deployer":
		tempEnt := &MasterDeployer{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "whitelisted_factory":
		tempEnt := &WhitelistedFactory{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "constant_product_pool_factory":
		tempEnt := &ConstantProductPoolFactory{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "constant_product_pool":
		tempEnt := &ConstantProductPool{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "concentrated_liquidity_pool_factory":
		tempEnt := &ConcentratedLiquidityPoolFactory{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "concentrated_liquidity_pool":
		tempEnt := &ConcentratedLiquidityPool{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "hybrid_pool_factory":
		tempEnt := &HybridPoolFactory{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "hybrid_pool":
		tempEnt := &HybridPool{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "index_pool_factory":
		tempEnt := &IndexPoolFactory{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "index_pool":
		tempEnt := &IndexPool{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "token":
		tempEnt := &Token{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "mint":
		tempEnt := &Mint{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "burn":
		tempEnt := &Burn{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "swap":
		tempEnt := &Swap{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	case "transaction":
		tempEnt := &Transaction{}
		err := json.Unmarshal(s.Entity, &tempEnt)
		if err != nil {
			return err
		}
		ent = tempEnt
	}

	t.Entity = ent
	t.Type = s.Type

	return nil
}

type TypedEvent struct {
	Type  string
	Event interface{}
}

func (t *TypedEvent) UnmarshalJSON(data []byte) error {
	s := &struct {
		Type  string
		Event json.RawMessage
	}{}

	err := json.Unmarshal(data, &s)
	if err != nil {
		return err
	}

	var event interface{}
	switch s.Type {
	case "ConcentratedLiquidityPoolBurnEvent":
		ev := &ConcentratedLiquidityPoolBurnEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConcentratedLiquidityPoolCollectEvent":
		ev := &ConcentratedLiquidityPoolCollectEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConcentratedLiquidityPoolMintEvent":
		ev := &ConcentratedLiquidityPoolMintEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConcentratedLiquidityPoolSwapEvent":
		ev := &ConcentratedLiquidityPoolSwapEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConcentratedLiquidityPoolSyncEvent":
		ev := &ConcentratedLiquidityPoolSyncEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConstantProductPoolApprovalEvent":
		ev := &ConstantProductPoolApprovalEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConstantProductPoolBurnEvent":
		ev := &ConstantProductPoolBurnEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConstantProductPoolMintEvent":
		ev := &ConstantProductPoolMintEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConstantProductPoolSwapEvent":
		ev := &ConstantProductPoolSwapEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConstantProductPoolSyncEvent":
		ev := &ConstantProductPoolSyncEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "ConstantProductPoolTransferEvent":
		ev := &ConstantProductPoolTransferEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "HybridPoolApprovalEvent":
		ev := &HybridPoolApprovalEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "HybridPoolBurnEvent":
		ev := &HybridPoolBurnEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "HybridPoolMintEvent":
		ev := &HybridPoolMintEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "HybridPoolSwapEvent":
		ev := &HybridPoolSwapEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "HybridPoolSyncEvent":
		ev := &HybridPoolSyncEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "HybridPoolTransferEvent":
		ev := &HybridPoolTransferEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "IndexPoolApprovalEvent":
		ev := &IndexPoolApprovalEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "IndexPoolBurnEvent":
		ev := &IndexPoolBurnEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "IndexPoolMintEvent":
		ev := &IndexPoolMintEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "IndexPoolSwapEvent":
		ev := &IndexPoolSwapEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "IndexPoolTransferEvent":
		ev := &IndexPoolTransferEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerAddToWhitelistEvent":
		ev := &MasterDeployerAddToWhitelistEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerBarFeeUpdatedEvent":
		ev := &MasterDeployerBarFeeUpdatedEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerDeployPoolEvent":
		ev := &MasterDeployerDeployPoolEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerMigratorUpdatedEvent":
		ev := &MasterDeployerMigratorUpdatedEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerRemoveFromWhitelistEvent":
		ev := &MasterDeployerRemoveFromWhitelistEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerTransferOwnerEvent":
		ev := &MasterDeployerTransferOwnerEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	case "MasterDeployerTransferOwnerClaimEvent":
		ev := &MasterDeployerTransferOwnerClaimEvent{}
		err := json.Unmarshal(s.Event, &ev)
		if err != nil {
			return err
		}
		event = ev
	}

	t.Event = event
	t.Type = s.Type

	return nil
}
